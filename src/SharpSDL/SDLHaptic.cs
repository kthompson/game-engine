// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SharpSDL
{
    /// <summary>The haptic structure used to identify an SDL haptic.</summary>
/// <remarks>
/// <para>SDL_HapticOpen</para>
/// <para>SDL_HapticOpenFromJoystick</para>
/// <para>SDL_HapticClose</para>
/// </remarks>
    public unsafe partial class SDL_Haptic
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.SDL_Haptic> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.SDL_Haptic>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.SDL_Haptic __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.SDL_Haptic(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.SDL_Haptic __CreateInstance(global::SharpSDL.SDL_Haptic.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.SDL_Haptic(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.SDL_Haptic.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.SDL_Haptic.__Internal));
            *(global::SharpSDL.SDL_Haptic.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SDL_Haptic(global::SharpSDL.SDL_Haptic.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SDL_Haptic(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Structure that represents a haptic direction.</summary>
/// <remarks>
/// <para>This is the direction where the force comes from,</para>
/// <para>instead of the direction in which the force is exerted.</para>
/// <para>Directions can be specified by:</para>
/// <para>- ::SDL_HAPTIC_POLAR : Specified by polar coordinates.</para>
/// <para>- ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.</para>
/// <para>- ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.</para>
/// <para>Cardinal directions of the haptic device are relative to the positioning</para>
/// <para>of the device.  North is considered to be away from the user.</para>
/// <para>The following diagram represents the cardinal directions:</para>
/// <para>If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a</para>
/// <para>degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses</para>
/// <para>the firstparameter.  The cardinal directions would be:</para>
/// <para>- North: 0 (0 degrees)</para>
/// <para>- East: 9000 (90 degrees)</para>
/// <para>- South: 18000 (180 degrees)</para>
/// <para>- West: 27000 (270 degrees)</para>
/// <para>If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions</para>
/// <para>(X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses</para>
/// <para>the first threeparameters.  The cardinal directions would be:</para>
/// <para>- North:  0,-1, 0</para>
/// <para>- East:   1, 0, 0</para>
/// <para>- South:  0, 1, 0</para>
/// <para>- West:  -1, 0, 0</para>
/// <para>The Z axis represents the height of the effect if supported, otherwise</para>
/// <para>it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you</para>
/// <para>can use any multiple you want, only the direction matters.</para>
/// <para>If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.</para>
/// <para>The first twoparameters are used.  Theparameters are as</para>
/// <para>follows (all values are in hundredths of degrees):</para>
/// <para>- Degrees from (1, 0) rotated towards (0, 1).</para>
/// <para>- Degrees towards (0, 0, 1) (device needs at least 3 axes).</para>
/// <para>Example of force coming from the south with all encodings (force coming</para>
/// <para>from the south means the user will have to pull the stick to counteract):</para>
/// <para>SDL_HAPTIC_POLAR</para>
/// <para>SDL_HAPTIC_CARTESIAN</para>
/// <para>SDL_HAPTIC_SPHERICAL</para>
/// <para>SDL_HapticEffect</para>
/// <para>SDL_HapticNumAxes</para>
/// </remarks>
    public unsafe partial class HapticDirection : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte type;

            [FieldOffset(4)]
            internal fixed int dir[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticDirection@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticDirection> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticDirection>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.HapticDirection __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticDirection(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticDirection __CreateInstance(global::SharpSDL.HapticDirection.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticDirection(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.HapticDirection.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticDirection.__Internal));
            *(global::SharpSDL.HapticDirection.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticDirection(global::SharpSDL.HapticDirection.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HapticDirection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HapticDirection()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticDirection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HapticDirection(global::SharpSDL.HapticDirection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticDirection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.HapticDirection.__Internal*) __Instance) = *((global::SharpSDL.HapticDirection.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.HapticDirection __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Type
        {
            get
            {
                return ((global::SharpSDL.HapticDirection.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::SharpSDL.HapticDirection.__Internal*)__Instance)->type = value;
            }
        }

        public int[] Dir
        {
            get
            {
                int[] __value = null;
                if (((global::SharpSDL.HapticDirection.__Internal*) __Instance)->dir != null)
                {
                    __value = new int[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::SharpSDL.HapticDirection.__Internal*) __Instance)->dir[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::SharpSDL.HapticDirection.__Internal*)__Instance)->dir[i] = value[i];
                }
            }
        }
    }

    /// <summary>A structure containing a template for a Constant effect.</summary>
/// <remarks>
/// <para>This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.</para>
/// <para>A constant effect applies a constant force in the specified direction</para>
/// <para>to the joystick.</para>
/// <para>SDL_HAPTIC_CONSTANT</para>
/// <para>SDL_HapticEffect</para>
/// </remarks>
    public unsafe partial class HapticConstant : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(4)]
            internal global::SharpSDL.HapticDirection.__Internal direction;

            [FieldOffset(20)]
            internal uint length;

            [FieldOffset(24)]
            internal ushort delay;

            [FieldOffset(26)]
            internal ushort button;

            [FieldOffset(28)]
            internal ushort interval;

            [FieldOffset(30)]
            internal short level;

            [FieldOffset(32)]
            internal ushort attack_length;

            [FieldOffset(34)]
            internal ushort attack_level;

            [FieldOffset(36)]
            internal ushort fade_length;

            [FieldOffset(38)]
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticConstant@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticConstant> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticConstant>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.HapticConstant __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticConstant(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticConstant __CreateInstance(global::SharpSDL.HapticConstant.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticConstant(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.HapticConstant.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticConstant.__Internal));
            *(global::SharpSDL.HapticConstant.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticConstant(global::SharpSDL.HapticConstant.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HapticConstant(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HapticConstant()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HapticConstant(global::SharpSDL.HapticConstant _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.HapticConstant.__Internal*) __Instance) = *((global::SharpSDL.HapticConstant.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.HapticConstant __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Type
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->type = value;
            }
        }

        public global::SharpSDL.HapticDirection Direction
        {
            get
            {
                return global::SharpSDL.HapticDirection.__CreateInstance(new global::System.IntPtr(&((global::SharpSDL.HapticConstant.__Internal*) __Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->direction = *(global::SharpSDL.HapticDirection.__Internal*) value.__Instance;
            }
        }

        public uint Length
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->length;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->length = value;
            }
        }

        public ushort Delay
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->delay;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->delay = value;
            }
        }

        public ushort Button
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->button;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->button = value;
            }
        }

        public ushort Interval
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->interval;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->interval = value;
            }
        }

        public short Level
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->level;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->level = value;
            }
        }

        public ushort AttackLength
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->attack_length;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->attack_length = value;
            }
        }

        public ushort AttackLevel
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->attack_level;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->attack_level = value;
            }
        }

        public ushort FadeLength
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->fade_length;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->fade_length = value;
            }
        }

        public ushort FadeLevel
        {
            get
            {
                return ((global::SharpSDL.HapticConstant.__Internal*) __Instance)->fade_level;
            }

            set
            {
                ((global::SharpSDL.HapticConstant.__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>A structure containing a template for a Periodic effect.</summary>
/// <remarks>
/// <para>The struct handles the following effects:</para>
/// <para>- ::SDL_HAPTIC_SINE</para>
/// <para>- ::SDL_HAPTIC_LEFTRIGHT</para>
/// <para>- ::SDL_HAPTIC_TRIANGLE</para>
/// <para>- ::SDL_HAPTIC_SAWTOOTHUP</para>
/// <para>- ::SDL_HAPTIC_SAWTOOTHDOWN</para>
/// <para>A periodic effect consists in a wave-shaped effect that repeats itself</para>
/// <para>over time.  The type determines the shape of the wave and the parameters</para>
/// <para>determine the dimensions of the wave.</para>
/// <para>Phase is given by hundredth of a degree meaning that giving the phase a value</para>
/// <para>of 9000 will displace it 25% of its period.  Here are sample values:</para>
/// <para>-     0: No phase displacement.</para>
/// <para>-  9000: Displaced 25% of its period.</para>
/// <para>- 18000: Displaced 50% of its period.</para>
/// <para>- 27000: Displaced 75% of its period.</para>
/// <para>- 36000: Displaced 100% of its period, same as 0, but 0 is preferred.</para>
/// <para>Examples:</para>
/// <para>SDL_HAPTIC_SINE</para>
/// <para>SDL_HAPTIC_LEFTRIGHT</para>
/// <para>SDL_HAPTIC_TRIANGLE</para>
/// <para>SDL_HAPTIC_SAWTOOTHUP</para>
/// <para>SDL_HAPTIC_SAWTOOTHDOWN</para>
/// <para>SDL_HapticEffect</para>
/// </remarks>
    public unsafe partial class HapticPeriodic : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(4)]
            internal global::SharpSDL.HapticDirection.__Internal direction;

            [FieldOffset(20)]
            internal uint length;

            [FieldOffset(24)]
            internal ushort delay;

            [FieldOffset(26)]
            internal ushort button;

            [FieldOffset(28)]
            internal ushort interval;

            [FieldOffset(30)]
            internal ushort period;

            [FieldOffset(32)]
            internal short magnitude;

            [FieldOffset(34)]
            internal short offset;

            [FieldOffset(36)]
            internal ushort phase;

            [FieldOffset(38)]
            internal ushort attack_length;

            [FieldOffset(40)]
            internal ushort attack_level;

            [FieldOffset(42)]
            internal ushort fade_length;

            [FieldOffset(44)]
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticPeriodic@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticPeriodic> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticPeriodic>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.HapticPeriodic __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticPeriodic(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticPeriodic __CreateInstance(global::SharpSDL.HapticPeriodic.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticPeriodic(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.HapticPeriodic.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticPeriodic.__Internal));
            *(global::SharpSDL.HapticPeriodic.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticPeriodic(global::SharpSDL.HapticPeriodic.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HapticPeriodic(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HapticPeriodic()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticPeriodic.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HapticPeriodic(global::SharpSDL.HapticPeriodic _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticPeriodic.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.HapticPeriodic.__Internal*) __Instance) = *((global::SharpSDL.HapticPeriodic.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.HapticPeriodic __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Type
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->type = value;
            }
        }

        public global::SharpSDL.HapticDirection Direction
        {
            get
            {
                return global::SharpSDL.HapticDirection.__CreateInstance(new global::System.IntPtr(&((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->direction = *(global::SharpSDL.HapticDirection.__Internal*) value.__Instance;
            }
        }

        public uint Length
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->length;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->length = value;
            }
        }

        public ushort Delay
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->delay;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->delay = value;
            }
        }

        public ushort Button
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->button;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->button = value;
            }
        }

        public ushort Interval
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->interval;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->interval = value;
            }
        }

        public ushort Period
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->period;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->period = value;
            }
        }

        public short Magnitude
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->magnitude;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->magnitude = value;
            }
        }

        public short Offset
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->offset;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->offset = value;
            }
        }

        public ushort Phase
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->phase;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->phase = value;
            }
        }

        public ushort AttackLength
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->attack_length;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->attack_length = value;
            }
        }

        public ushort AttackLevel
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->attack_level;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->attack_level = value;
            }
        }

        public ushort FadeLength
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->fade_length;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->fade_length = value;
            }
        }

        public ushort FadeLevel
        {
            get
            {
                return ((global::SharpSDL.HapticPeriodic.__Internal*) __Instance)->fade_level;
            }

            set
            {
                ((global::SharpSDL.HapticPeriodic.__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>A structure containing a template for a Condition effect.</summary>
/// <remarks>
/// <para>The struct handles the following effects:</para>
/// <para>- ::SDL_HAPTIC_SPRING: Effect based on axes position.</para>
/// <para>- ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.</para>
/// <para>- ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.</para>
/// <para>- ::SDL_HAPTIC_FRICTION: Effect based on axes movement.</para>
/// <para>Direction is handled by condition internals instead of a direction member.</para>
/// <para>The condition effect specific members have three parameters.  The first</para>
/// <para>refers to the X axis, the second refers to the Y axis and the third</para>
/// <para>refers to the Z axis.  The right terms refer to the positive side of the</para>
/// <para>axis and the left terms refer to the negative side of the axis.  Please</para>
/// <para>refer to the ::SDL_HapticDirection diagram for which side is positive and</para>
/// <para>which is negative.</para>
/// <para>SDL_HapticDirection</para>
/// <para>SDL_HAPTIC_SPRING</para>
/// <para>SDL_HAPTIC_DAMPER</para>
/// <para>SDL_HAPTIC_INERTIA</para>
/// <para>SDL_HAPTIC_FRICTION</para>
/// <para>SDL_HapticEffect</para>
/// </remarks>
    public unsafe partial class HapticCondition : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 68)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(4)]
            internal global::SharpSDL.HapticDirection.__Internal direction;

            [FieldOffset(20)]
            internal uint length;

            [FieldOffset(24)]
            internal ushort delay;

            [FieldOffset(26)]
            internal ushort button;

            [FieldOffset(28)]
            internal ushort interval;

            [FieldOffset(30)]
            internal fixed ushort right_sat[3];

            [FieldOffset(36)]
            internal fixed ushort left_sat[3];

            [FieldOffset(42)]
            internal fixed short right_coeff[3];

            [FieldOffset(48)]
            internal fixed short left_coeff[3];

            [FieldOffset(54)]
            internal fixed ushort deadband[3];

            [FieldOffset(60)]
            internal fixed short center[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticCondition@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticCondition> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticCondition>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.HapticCondition __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticCondition(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticCondition __CreateInstance(global::SharpSDL.HapticCondition.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticCondition(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.HapticCondition.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticCondition.__Internal));
            *(global::SharpSDL.HapticCondition.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticCondition(global::SharpSDL.HapticCondition.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HapticCondition(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HapticCondition()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticCondition.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HapticCondition(global::SharpSDL.HapticCondition _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticCondition.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.HapticCondition.__Internal*) __Instance) = *((global::SharpSDL.HapticCondition.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.HapticCondition __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Type
        {
            get
            {
                return ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->type = value;
            }
        }

        public global::SharpSDL.HapticDirection Direction
        {
            get
            {
                return global::SharpSDL.HapticDirection.__CreateInstance(new global::System.IntPtr(&((global::SharpSDL.HapticCondition.__Internal*) __Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->direction = *(global::SharpSDL.HapticDirection.__Internal*) value.__Instance;
            }
        }

        public uint Length
        {
            get
            {
                return ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->length;
            }

            set
            {
                ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->length = value;
            }
        }

        public ushort Delay
        {
            get
            {
                return ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->delay;
            }

            set
            {
                ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->delay = value;
            }
        }

        public ushort Button
        {
            get
            {
                return ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->button;
            }

            set
            {
                ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->button = value;
            }
        }

        public ushort Interval
        {
            get
            {
                return ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->interval;
            }

            set
            {
                ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->interval = value;
            }
        }

        public ushort[] RightSat
        {
            get
            {
                ushort[] __value = null;
                if (((global::SharpSDL.HapticCondition.__Internal*) __Instance)->right_sat != null)
                {
                    __value = new ushort[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->right_sat[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->right_sat[i] = value[i];
                }
            }
        }

        public ushort[] LeftSat
        {
            get
            {
                ushort[] __value = null;
                if (((global::SharpSDL.HapticCondition.__Internal*) __Instance)->left_sat != null)
                {
                    __value = new ushort[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->left_sat[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->left_sat[i] = value[i];
                }
            }
        }

        public short[] RightCoeff
        {
            get
            {
                short[] __value = null;
                if (((global::SharpSDL.HapticCondition.__Internal*) __Instance)->right_coeff != null)
                {
                    __value = new short[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->right_coeff[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->right_coeff[i] = value[i];
                }
            }
        }

        public short[] LeftCoeff
        {
            get
            {
                short[] __value = null;
                if (((global::SharpSDL.HapticCondition.__Internal*) __Instance)->left_coeff != null)
                {
                    __value = new short[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->left_coeff[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->left_coeff[i] = value[i];
                }
            }
        }

        public ushort[] Deadband
        {
            get
            {
                ushort[] __value = null;
                if (((global::SharpSDL.HapticCondition.__Internal*) __Instance)->deadband != null)
                {
                    __value = new ushort[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->deadband[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->deadband[i] = value[i];
                }
            }
        }

        public short[] Center
        {
            get
            {
                short[] __value = null;
                if (((global::SharpSDL.HapticCondition.__Internal*) __Instance)->center != null)
                {
                    __value = new short[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::SharpSDL.HapticCondition.__Internal*) __Instance)->center[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::SharpSDL.HapticCondition.__Internal*)__Instance)->center[i] = value[i];
                }
            }
        }
    }

    /// <summary>A structure containing a template for a Ramp effect.</summary>
/// <remarks>
/// <para>This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.</para>
/// <para>The ramp effect starts at start strength and ends at end strength.</para>
/// <para>It augments in linear fashion.  If you use attack and fade with a ramp</para>
/// <para>the effects get added to the ramp effect making the effect become</para>
/// <para>quadratic instead of linear.</para>
/// <para>SDL_HAPTIC_RAMP</para>
/// <para>SDL_HapticEffect</para>
/// </remarks>
    public unsafe partial class HapticRamp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(4)]
            internal global::SharpSDL.HapticDirection.__Internal direction;

            [FieldOffset(20)]
            internal uint length;

            [FieldOffset(24)]
            internal ushort delay;

            [FieldOffset(26)]
            internal ushort button;

            [FieldOffset(28)]
            internal ushort interval;

            [FieldOffset(30)]
            internal short start;

            [FieldOffset(32)]
            internal short end;

            [FieldOffset(34)]
            internal ushort attack_length;

            [FieldOffset(36)]
            internal ushort attack_level;

            [FieldOffset(38)]
            internal ushort fade_length;

            [FieldOffset(40)]
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticRamp@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticRamp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticRamp>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.HapticRamp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticRamp(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticRamp __CreateInstance(global::SharpSDL.HapticRamp.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticRamp(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.HapticRamp.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticRamp.__Internal));
            *(global::SharpSDL.HapticRamp.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticRamp(global::SharpSDL.HapticRamp.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HapticRamp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HapticRamp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticRamp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HapticRamp(global::SharpSDL.HapticRamp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticRamp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.HapticRamp.__Internal*) __Instance) = *((global::SharpSDL.HapticRamp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.HapticRamp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Type
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->type = value;
            }
        }

        public global::SharpSDL.HapticDirection Direction
        {
            get
            {
                return global::SharpSDL.HapticDirection.__CreateInstance(new global::System.IntPtr(&((global::SharpSDL.HapticRamp.__Internal*) __Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->direction = *(global::SharpSDL.HapticDirection.__Internal*) value.__Instance;
            }
        }

        public uint Length
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->length;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->length = value;
            }
        }

        public ushort Delay
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->delay;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->delay = value;
            }
        }

        public ushort Button
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->button;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->button = value;
            }
        }

        public ushort Interval
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->interval;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->interval = value;
            }
        }

        public short Start
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->start;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->start = value;
            }
        }

        public short End
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->end;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->end = value;
            }
        }

        public ushort AttackLength
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->attack_length;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->attack_length = value;
            }
        }

        public ushort AttackLevel
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->attack_level;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->attack_level = value;
            }
        }

        public ushort FadeLength
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->fade_length;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->fade_length = value;
            }
        }

        public ushort FadeLevel
        {
            get
            {
                return ((global::SharpSDL.HapticRamp.__Internal*) __Instance)->fade_level;
            }

            set
            {
                ((global::SharpSDL.HapticRamp.__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>A structure containing a template for a Left/Right effect.</summary>
/// <remarks>
/// <para>This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.</para>
/// <para>The Left/Right effect is used to explicitly control the large and small</para>
/// <para>motors, commonly found in modern game controllers. The small (right) motor</para>
/// <para>is high frequency, and the large (left) motor is low frequency.</para>
/// <para>SDL_HAPTIC_LEFTRIGHT</para>
/// <para>SDL_HapticEffect</para>
/// </remarks>
    public unsafe partial class HapticLeftRight : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(4)]
            internal uint length;

            [FieldOffset(8)]
            internal ushort large_magnitude;

            [FieldOffset(10)]
            internal ushort small_magnitude;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticLeftRight@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticLeftRight> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticLeftRight>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.HapticLeftRight __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticLeftRight(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticLeftRight __CreateInstance(global::SharpSDL.HapticLeftRight.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticLeftRight(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.HapticLeftRight.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticLeftRight.__Internal));
            *(global::SharpSDL.HapticLeftRight.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticLeftRight(global::SharpSDL.HapticLeftRight.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HapticLeftRight(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HapticLeftRight()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticLeftRight.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HapticLeftRight(global::SharpSDL.HapticLeftRight _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticLeftRight.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.HapticLeftRight.__Internal*) __Instance) = *((global::SharpSDL.HapticLeftRight.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.HapticLeftRight __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Type
        {
            get
            {
                return ((global::SharpSDL.HapticLeftRight.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::SharpSDL.HapticLeftRight.__Internal*)__Instance)->type = value;
            }
        }

        public uint Length
        {
            get
            {
                return ((global::SharpSDL.HapticLeftRight.__Internal*) __Instance)->length;
            }

            set
            {
                ((global::SharpSDL.HapticLeftRight.__Internal*)__Instance)->length = value;
            }
        }

        public ushort LargeMagnitude
        {
            get
            {
                return ((global::SharpSDL.HapticLeftRight.__Internal*) __Instance)->large_magnitude;
            }

            set
            {
                ((global::SharpSDL.HapticLeftRight.__Internal*)__Instance)->large_magnitude = value;
            }
        }

        public ushort SmallMagnitude
        {
            get
            {
                return ((global::SharpSDL.HapticLeftRight.__Internal*) __Instance)->small_magnitude;
            }

            set
            {
                ((global::SharpSDL.HapticLeftRight.__Internal*)__Instance)->small_magnitude = value;
            }
        }
    }

    /// <summary>A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.</summary>
/// <remarks>
/// <para>This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.</para>
/// <para>A custom force feedback effect is much like a periodic effect, where the</para>
/// <para>application can define its exact shape.  You will have to allocate the</para>
/// <para>data yourself.  Data should consist of channels * samples Uint16 samples.</para>
/// <para>If channels is one, the effect is rotated using the defined direction.</para>
/// <para>Otherwise it uses the samples in data for the different axes.</para>
/// <para>SDL_HAPTIC_CUSTOM</para>
/// <para>SDL_HapticEffect</para>
/// </remarks>
    public unsafe partial class HapticCustom : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(4)]
            internal global::SharpSDL.HapticDirection.__Internal direction;

            [FieldOffset(20)]
            internal uint length;

            [FieldOffset(24)]
            internal ushort delay;

            [FieldOffset(26)]
            internal ushort button;

            [FieldOffset(28)]
            internal ushort interval;

            [FieldOffset(30)]
            internal byte channels;

            [FieldOffset(32)]
            internal ushort period;

            [FieldOffset(34)]
            internal ushort samples;

            [FieldOffset(40)]
            internal global::System.IntPtr data;

            [FieldOffset(48)]
            internal ushort attack_length;

            [FieldOffset(50)]
            internal ushort attack_level;

            [FieldOffset(52)]
            internal ushort fade_length;

            [FieldOffset(54)]
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticCustom@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticCustom> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.HapticCustom>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.HapticCustom __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticCustom(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticCustom __CreateInstance(global::SharpSDL.HapticCustom.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticCustom(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.HapticCustom.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticCustom.__Internal));
            *(global::SharpSDL.HapticCustom.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticCustom(global::SharpSDL.HapticCustom.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HapticCustom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HapticCustom()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticCustom.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HapticCustom(global::SharpSDL.HapticCustom _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.HapticCustom.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.HapticCustom.__Internal*) __Instance) = *((global::SharpSDL.HapticCustom.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.HapticCustom __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Type
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->type = value;
            }
        }

        public global::SharpSDL.HapticDirection Direction
        {
            get
            {
                return global::SharpSDL.HapticDirection.__CreateInstance(new global::System.IntPtr(&((global::SharpSDL.HapticCustom.__Internal*) __Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->direction = *(global::SharpSDL.HapticDirection.__Internal*) value.__Instance;
            }
        }

        public uint Length
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->length;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->length = value;
            }
        }

        public ushort Delay
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->delay;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->delay = value;
            }
        }

        public ushort Button
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->button;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->button = value;
            }
        }

        public ushort Interval
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->interval;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->interval = value;
            }
        }

        public byte Channels
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->channels;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->channels = value;
            }
        }

        public ushort Period
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->period;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->period = value;
            }
        }

        public ushort Samples
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->samples;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->samples = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public ushort AttackLength
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->attack_length;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->attack_length = value;
            }
        }

        public ushort AttackLevel
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->attack_level;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->attack_level = value;
            }
        }

        public ushort FadeLength
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->fade_length;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->fade_length = value;
            }
        }

        public ushort FadeLevel
        {
            get
            {
                return ((global::SharpSDL.HapticCustom.__Internal*) __Instance)->fade_level;
            }

            set
            {
                ((global::SharpSDL.HapticCustom.__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>The generic template for any haptic effect.</summary>
/// <remarks>
/// <para>All values max at 32767 (0x7FFF).  Signed values also can be negative.</para>
/// <para>Time values unless specified otherwise are in milliseconds.</para>
/// <para>You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767</para>
/// <para>value.  Neither delay, interval, attack_length nor fade_length support</para>
/// <para>::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.</para>
/// <para>Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of</para>
/// <para>::SDL_HAPTIC_INFINITY.</para>
/// <para>Button triggers may not be supported on all devices, it is advised to not</para>
/// <para>use them if possible.  Buttons start at index 1 instead of index 0 like</para>
/// <para>the joystick.</para>
/// <para>If both attack_length and fade_level are 0, the envelope is not used,</para>
/// <para>otherwise both values are used.</para>
/// <para>Common parts:</para>
/// <para>Here we have an example of a constant effect evolution in time:</para>
/// <para>Note either the attack_level or the fade_level may be above the actual</para>
/// <para>effect level.</para>
/// <para>SDL_HapticConstant</para>
/// <para>SDL_HapticPeriodic</para>
/// <para>SDL_HapticCondition</para>
/// <para>SDL_HapticRamp</para>
/// <para>SDL_HapticLeftRight</para>
/// <para>SDL_HapticCustom</para>
/// </remarks>
    public unsafe partial struct HapticEffect
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(0)]
            internal global::SharpSDL.HapticConstant.__Internal constant;

            [FieldOffset(0)]
            internal global::SharpSDL.HapticPeriodic.__Internal periodic;

            [FieldOffset(0)]
            internal global::SharpSDL.HapticCondition.__Internal condition;

            [FieldOffset(0)]
            internal global::SharpSDL.HapticRamp.__Internal ramp;

            [FieldOffset(0)]
            internal global::SharpSDL.HapticLeftRight.__Internal leftright;

            [FieldOffset(0)]
            internal global::SharpSDL.HapticCustom.__Internal custom;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_HapticEffect@@QEAA@AEBT0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        private HapticEffect.__Internal __instance;
        internal HapticEffect.__Internal __Instance { get { return __instance; } }

        internal static global::SharpSDL.HapticEffect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticEffect(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.HapticEffect __CreateInstance(global::SharpSDL.HapticEffect.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.HapticEffect(native, skipVTables);
        }

        private HapticEffect(global::SharpSDL.HapticEffect.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private HapticEffect(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::SharpSDL.HapticEffect.__Internal*) native;
        }

        public HapticEffect(global::SharpSDL.HapticEffect _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public ushort Type
        {
            get
            {
                return __instance.type;
            }

            set
            {
                __instance.type = value;
            }
        }

        public global::SharpSDL.HapticConstant Constant
        {
            get
            {
                return global::SharpSDL.HapticConstant.__CreateInstance(__instance.constant);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.constant = *(global::SharpSDL.HapticConstant.__Internal*) value.__Instance;
            }
        }

        public global::SharpSDL.HapticPeriodic Periodic
        {
            get
            {
                return global::SharpSDL.HapticPeriodic.__CreateInstance(__instance.periodic);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.periodic = *(global::SharpSDL.HapticPeriodic.__Internal*) value.__Instance;
            }
        }

        public global::SharpSDL.HapticCondition Condition
        {
            get
            {
                return global::SharpSDL.HapticCondition.__CreateInstance(__instance.condition);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.condition = *(global::SharpSDL.HapticCondition.__Internal*) value.__Instance;
            }
        }

        public global::SharpSDL.HapticRamp Ramp
        {
            get
            {
                return global::SharpSDL.HapticRamp.__CreateInstance(__instance.ramp);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.ramp = *(global::SharpSDL.HapticRamp.__Internal*) value.__Instance;
            }
        }

        public global::SharpSDL.HapticLeftRight Leftright
        {
            get
            {
                return global::SharpSDL.HapticLeftRight.__CreateInstance(__instance.leftright);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.leftright = *(global::SharpSDL.HapticLeftRight.__Internal*) value.__Instance;
            }
        }

        public global::SharpSDL.HapticCustom Custom
        {
            get
            {
                return global::SharpSDL.HapticCustom.__CreateInstance(__instance.custom);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.custom = *(global::SharpSDL.HapticCustom.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SDL_haptic
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_NumHaptics")]
            internal static extern int NumHaptics();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticName")]
            internal static extern global::System.IntPtr HapticName(int device_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticOpen")]
            internal static extern global::System.IntPtr HapticOpen(int device_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticOpened")]
            internal static extern int HapticOpened(int device_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticIndex")]
            internal static extern int HapticIndex(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_MouseIsHaptic")]
            internal static extern int MouseIsHaptic();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticOpenFromMouse")]
            internal static extern global::System.IntPtr HapticOpenFromMouse();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_JoystickIsHaptic")]
            internal static extern int JoystickIsHaptic(global::System.IntPtr joystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticOpenFromJoystick")]
            internal static extern global::System.IntPtr HapticOpenFromJoystick(global::System.IntPtr joystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticClose")]
            internal static extern void HapticClose(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticNumEffects")]
            internal static extern int HapticNumEffects(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticNumEffectsPlaying")]
            internal static extern int HapticNumEffectsPlaying(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticQuery")]
            internal static extern uint HapticQuery(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticNumAxes")]
            internal static extern int HapticNumAxes(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticEffectSupported")]
            internal static extern int HapticEffectSupported(global::System.IntPtr haptic, global::System.IntPtr effect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticNewEffect")]
            internal static extern int HapticNewEffect(global::System.IntPtr haptic, global::System.IntPtr effect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticUpdateEffect")]
            internal static extern int HapticUpdateEffect(global::System.IntPtr haptic, int effect, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticRunEffect")]
            internal static extern int HapticRunEffect(global::System.IntPtr haptic, int effect, uint iterations);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticStopEffect")]
            internal static extern int HapticStopEffect(global::System.IntPtr haptic, int effect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticDestroyEffect")]
            internal static extern void HapticDestroyEffect(global::System.IntPtr haptic, int effect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticGetEffectStatus")]
            internal static extern int HapticGetEffectStatus(global::System.IntPtr haptic, int effect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticSetGain")]
            internal static extern int HapticSetGain(global::System.IntPtr haptic, int gain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticSetAutocenter")]
            internal static extern int HapticSetAutocenter(global::System.IntPtr haptic, int autocenter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticPause")]
            internal static extern int HapticPause(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticUnpause")]
            internal static extern int HapticUnpause(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticStopAll")]
            internal static extern int HapticStopAll(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticRumbleSupported")]
            internal static extern int HapticRumbleSupported(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticRumbleInit")]
            internal static extern int HapticRumbleInit(global::System.IntPtr haptic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticRumblePlay")]
            internal static extern int HapticRumblePlay(global::System.IntPtr haptic, float strength, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HapticRumbleStop")]
            internal static extern int HapticRumbleStop(global::System.IntPtr haptic);
        }

        /// <summary>Count the number of haptic devices attached to the system.</summary>
/// <returns>Number of haptic devices detected on the system.</returns>
        public static int NumHaptics()
        {
            var __ret = __Internal.NumHaptics();
            return __ret;
        }

        /// <summary>Get the implementation dependent name of a haptic device.</summary>
/// <param name="device_index">Index of the device to get its name.</param>
/// <returns>Name of the device or NULL on error.</returns>
/// <remarks>
/// <para>This can be called before any joysticks are opened.</para>
/// <para>If no name can be found, this function returns NULL.</para>
/// <para>SDL_NumHaptics</para>
/// </remarks>
        public static string HapticName(int device_index)
        {
            var __ret = __Internal.HapticName(device_index);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Opens a haptic device for use.</summary>
/// <param name="device_index">Index of the device to open.</param>
/// <returns>Device identifier or NULL on error.</returns>
/// <remarks>
/// <para>The index passed as an argument refers to the N'th haptic device on this</para>
/// <para>system.</para>
/// <para>When opening a haptic device, its gain will be set to maximum and</para>
/// <para>autocenter will be disabled.  To modify these values use</para>
/// <para>SDL_HapticSetGain() and SDL_HapticSetAutocenter().</para>
/// <para>SDL_HapticIndex</para>
/// <para>SDL_HapticOpenFromMouse</para>
/// <para>SDL_HapticOpenFromJoystick</para>
/// <para>SDL_HapticClose</para>
/// <para>SDL_HapticSetGain</para>
/// <para>SDL_HapticSetAutocenter</para>
/// <para>SDL_HapticPause</para>
/// <para>SDL_HapticStopAll</para>
/// </remarks>
        public static global::SharpSDL.SDL_Haptic HapticOpen(int device_index)
        {
            var __ret = __Internal.HapticOpen(device_index);
            global::SharpSDL.SDL_Haptic __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.SDL_Haptic.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.SDL_Haptic) global::SharpSDL.SDL_Haptic.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.SDL_Haptic.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Checks if the haptic device at index has been opened.</summary>
/// <param name="device_index">Index to check to see if it has been opened.</param>
/// <returns>1 if it has been opened or 0 if it hasn't.</returns>
/// <remarks>
/// <para>SDL_HapticOpen</para>
/// <para>SDL_HapticIndex</para>
/// </remarks>
        public static int HapticOpened(int device_index)
        {
            var __ret = __Internal.HapticOpened(device_index);
            return __ret;
        }

        /// <summary>Gets the index of a haptic device.</summary>
/// <param name="haptic">Haptic device to get the index of.</param>
/// <returns>The index of the haptic device or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticOpen</para>
/// <para>SDL_HapticOpened</para>
/// </remarks>
        public static int HapticIndex(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticIndex(__arg0);
            return __ret;
        }

        /// <summary>Gets whether or not the current mouse has haptic capabilities.</summary>
/// <returns>SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.</returns>
/// <remarks>SDL_HapticOpenFromMouse</remarks>
        public static int MouseIsHaptic()
        {
            var __ret = __Internal.MouseIsHaptic();
            return __ret;
        }

        /// <summary>Tries to open a haptic device from the current mouse.</summary>
/// <returns>The haptic device identifier or NULL on error.</returns>
/// <remarks>
/// <para>SDL_MouseIsHaptic</para>
/// <para>SDL_HapticOpen</para>
/// </remarks>
        public static global::SharpSDL.SDL_Haptic HapticOpenFromMouse()
        {
            var __ret = __Internal.HapticOpenFromMouse();
            global::SharpSDL.SDL_Haptic __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.SDL_Haptic.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.SDL_Haptic) global::SharpSDL.SDL_Haptic.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.SDL_Haptic.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Checks to see if a joystick has haptic features.</summary>
/// <param name="joystick">Joystick to test for haptic capabilities.</param>
/// <returns>
/// <para>SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't</para>
/// <para>or -1 if an error occurred.</para>
/// </returns>
/// <remarks>SDL_HapticOpenFromJoystick</remarks>
        public static int JoystickIsHaptic(global::SharpSDL.SDL_Joystick joystick)
        {
            var __arg0 = ReferenceEquals(joystick, null) ? global::System.IntPtr.Zero : joystick.__Instance;
            var __ret = __Internal.JoystickIsHaptic(__arg0);
            return __ret;
        }

        /// <summary>Opens a haptic device for use from a joystick device.</summary>
/// <param name="joystick">Joystick to create a haptic device from.</param>
/// <returns>A valid haptic device identifier on success or NULL on error.</returns>
/// <remarks>
/// <para>You must still close the haptic device separately.  It will not be closed</para>
/// <para>with the joystick.</para>
/// <para>When opening from a joystick you should first close the haptic device before</para>
/// <para>closing the joystick device.  If not, on some implementations the haptic</para>
/// <para>device will also get unallocated and you'll be unable to use force feedback</para>
/// <para>on that device.</para>
/// <para>SDL_HapticOpen</para>
/// <para>SDL_HapticClose</para>
/// </remarks>
        public static global::SharpSDL.SDL_Haptic HapticOpenFromJoystick(global::SharpSDL.SDL_Joystick joystick)
        {
            var __arg0 = ReferenceEquals(joystick, null) ? global::System.IntPtr.Zero : joystick.__Instance;
            var __ret = __Internal.HapticOpenFromJoystick(__arg0);
            global::SharpSDL.SDL_Haptic __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.SDL_Haptic.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.SDL_Haptic) global::SharpSDL.SDL_Haptic.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.SDL_Haptic.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Closes a haptic device previously opened with SDL_HapticOpen().</summary>
/// <param name="haptic">Haptic device to close.</param>
        public static void HapticClose(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            __Internal.HapticClose(__arg0);
        }

        /// <summary>Returns the number of effects a haptic device can store.</summary>
/// <param name="haptic">The haptic device to query effect max.</param>
/// <returns>
/// <para>The number of effects the haptic device can store or</para>
/// <para>-1 on error.</para>
/// </returns>
/// <remarks>
/// <para>On some platforms this isn't fully supported, and therefore is an</para>
/// <para>approximation.  Always check to see if your created effect was actually</para>
/// <para>created and do not rely solely on SDL_HapticNumEffects().</para>
/// <para>SDL_HapticNumEffectsPlaying</para>
/// <para>SDL_HapticQuery</para>
/// </remarks>
        public static int HapticNumEffects(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticNumEffects(__arg0);
            return __ret;
        }

        /// <summary>
/// <para>Returns the number of effects a haptic device can play at the same</para>
/// <para>time.</para>
/// </summary>
/// <param name="haptic">The haptic device to query maximum playing effects.</param>
/// <returns>
/// <para>The number of effects the haptic device can play at the same time</para>
/// <para>or -1 on error.</para>
/// </returns>
/// <remarks>
/// <para>This is not supported on all platforms, but will always return a value.</para>
/// <para>Added here for the sake of completeness.</para>
/// <para>SDL_HapticNumEffects</para>
/// <para>SDL_HapticQuery</para>
/// </remarks>
        public static int HapticNumEffectsPlaying(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticNumEffectsPlaying(__arg0);
            return __ret;
        }

        /// <summary>Gets the haptic device's supported features in bitwise manner.</summary>
/// <param name="haptic">The haptic device to query.</param>
/// <returns>Haptic features in bitwise manner (OR'd).</returns>
/// <remarks>
/// <para>Example:</para>
/// <para>SDL_HapticNumEffects</para>
/// <para>SDL_HapticEffectSupported</para>
/// </remarks>
        public static uint HapticQuery(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticQuery(__arg0);
            return __ret;
        }

        /// <summary>Gets the number of haptic axes the device has.</summary>
/// <remarks>SDL_HapticDirection</remarks>
        public static int HapticNumAxes(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticNumAxes(__arg0);
            return __ret;
        }

        /// <summary>Checks to see if effect is supported by haptic.</summary>
/// <param name="haptic">Haptic device to check on.</param>
/// <param name="effect">Effect to check to see if it is supported.</param>
/// <returns>SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticQuery</para>
/// <para>SDL_HapticNewEffect</para>
/// </remarks>
        public static int HapticEffectSupported(global::SharpSDL.SDL_Haptic haptic, global::SharpSDL.HapticEffect effect)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var ____arg1 = effect.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.HapticEffectSupported(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Creates a new haptic effect on the device.</summary>
/// <param name="haptic">Haptic device to create the effect on.</param>
/// <param name="effect">Properties of the effect to create.</param>
/// <returns>The identifier of the effect on success or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticUpdateEffect</para>
/// <para>SDL_HapticRunEffect</para>
/// <para>SDL_HapticDestroyEffect</para>
/// </remarks>
        public static int HapticNewEffect(global::SharpSDL.SDL_Haptic haptic, global::SharpSDL.HapticEffect effect)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var ____arg1 = effect.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.HapticNewEffect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Updates the properties of an effect.</summary>
/// <param name="haptic">Haptic device that has the effect.</param>
/// <param name="effect">Identifier of the effect to update.</param>
/// <param name="data">New effect properties to use.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>Can be used dynamically, although behavior when dynamically changing</para>
/// <para>direction may be strange.  Specifically the effect may reupload itself</para>
/// <para>and start playing from the start.  You cannot change the type either when</para>
/// <para>running SDL_HapticUpdateEffect().</para>
/// <para>SDL_HapticNewEffect</para>
/// <para>SDL_HapticRunEffect</para>
/// <para>SDL_HapticDestroyEffect</para>
/// </remarks>
        public static int HapticUpdateEffect(global::SharpSDL.SDL_Haptic haptic, int effect, global::SharpSDL.HapticEffect data)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var ____arg2 = data.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.HapticUpdateEffect(__arg0, effect, __arg2);
            return __ret;
        }

        /// <summary>Runs the haptic effect on its associated haptic device.</summary>
/// <param name="haptic">Haptic device to run the effect on.</param>
/// <param name="effect">Identifier of the haptic effect to run.</param>
/// <param name="iterations">
/// <para>Number of iterations to run the effect. Use</para>
/// <para>::SDL_HAPTIC_INFINITY for infinity.</para>
/// </param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over</para>
/// <para>repeating the envelope (attack and fade) every time.  If you only want the</para>
/// <para>effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length</para>
/// <para>parameter.</para>
/// <para>SDL_HapticStopEffect</para>
/// <para>SDL_HapticDestroyEffect</para>
/// <para>SDL_HapticGetEffectStatus</para>
/// </remarks>
        public static int HapticRunEffect(global::SharpSDL.SDL_Haptic haptic, int effect, uint iterations)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticRunEffect(__arg0, effect, iterations);
            return __ret;
        }

        /// <summary>Stops the haptic effect on its associated haptic device.</summary>
/// <param name="haptic">Haptic device to stop the effect on.</param>
/// <param name="effect">Identifier of the effect to stop.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticRunEffect</para>
/// <para>SDL_HapticDestroyEffect</para>
/// </remarks>
        public static int HapticStopEffect(global::SharpSDL.SDL_Haptic haptic, int effect)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticStopEffect(__arg0, effect);
            return __ret;
        }

        /// <summary>Destroys a haptic effect on the device.</summary>
/// <param name="haptic">Device to destroy the effect on.</param>
/// <param name="effect">Identifier of the effect to destroy.</param>
/// <remarks>
/// <para>This will stop the effect if it's running.  Effects are automatically</para>
/// <para>destroyed when the device is closed.</para>
/// <para>SDL_HapticNewEffect</para>
/// </remarks>
        public static void HapticDestroyEffect(global::SharpSDL.SDL_Haptic haptic, int effect)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            __Internal.HapticDestroyEffect(__arg0, effect);
        }

        /// <summary>Gets the status of the current effect on the haptic device.</summary>
/// <param name="haptic">Haptic device to query the effect status on.</param>
/// <param name="effect">Identifier of the effect to query its status.</param>
/// <returns>0 if it isn't playing, 1 if it is playing or -1 on error.</returns>
/// <remarks>
/// <para>Device must support the ::SDL_HAPTIC_STATUS feature.</para>
/// <para>SDL_HapticRunEffect</para>
/// <para>SDL_HapticStopEffect</para>
/// </remarks>
        public static int HapticGetEffectStatus(global::SharpSDL.SDL_Haptic haptic, int effect)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticGetEffectStatus(__arg0, effect);
            return __ret;
        }

        /// <summary>Sets the global gain of the device.</summary>
/// <param name="haptic">Haptic device to set the gain on.</param>
/// <param name="gain">Value to set the gain to, should be between 0 and 100.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>Device must support the ::SDL_HAPTIC_GAIN feature.</para>
/// <para>The user may specify the maximum gain by setting the environment variable</para>
/// <para>SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to</para>
/// <para>SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the</para>
/// <para>maximum.</para>
/// <para>SDL_HapticQuery</para>
/// </remarks>
        public static int HapticSetGain(global::SharpSDL.SDL_Haptic haptic, int gain)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticSetGain(__arg0, gain);
            return __ret;
        }

        /// <summary>Sets the global autocenter of the device.</summary>
/// <param name="haptic">Haptic device to set autocentering on.</param>
/// <param name="autocenter">Value to set autocenter to, 0 disables autocentering.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>Autocenter should be between 0 and 100.  Setting it to 0 will disable</para>
/// <para>autocentering.</para>
/// <para>Device must support the ::SDL_HAPTIC_AUTOCENTER feature.</para>
/// <para>SDL_HapticQuery</para>
/// </remarks>
        public static int HapticSetAutocenter(global::SharpSDL.SDL_Haptic haptic, int autocenter)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticSetAutocenter(__arg0, autocenter);
            return __ret;
        }

        /// <summary>Pauses a haptic device.</summary>
/// <param name="haptic">Haptic device to pause.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>Device must support the ::SDL_HAPTIC_PAUSE feature.  Call</para>
/// <para>SDL_HapticUnpause() to resume playback.</para>
/// <para>Do not modify the effects nor add new ones while the device is paused.</para>
/// <para>That can cause all sorts of weird errors.</para>
/// <para>SDL_HapticUnpause</para>
/// </remarks>
        public static int HapticPause(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticPause(__arg0);
            return __ret;
        }

        /// <summary>Unpauses a haptic device.</summary>
/// <param name="haptic">Haptic device to unpause.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>Call to unpause after SDL_HapticPause().</para>
/// <para>SDL_HapticPause</para>
/// </remarks>
        public static int HapticUnpause(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticUnpause(__arg0);
            return __ret;
        }

        /// <summary>Stops all the currently playing effects on a haptic device.</summary>
/// <param name="haptic">Haptic device to stop.</param>
/// <returns>0 on success or -1 on error.</returns>
        public static int HapticStopAll(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticStopAll(__arg0);
            return __ret;
        }

        /// <summary>Checks to see if rumble is supported on a haptic device.</summary>
/// <param name="haptic">Haptic device to check to see if it supports rumble.</param>
/// <returns>SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticRumbleInit</para>
/// <para>SDL_HapticRumblePlay</para>
/// <para>SDL_HapticRumbleStop</para>
/// </remarks>
        public static int HapticRumbleSupported(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticRumbleSupported(__arg0);
            return __ret;
        }

        /// <summary>Initializes the haptic device for simple rumble playback.</summary>
/// <param name="haptic">Haptic device to initialize for simple rumble playback.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticOpen</para>
/// <para>SDL_HapticRumbleSupported</para>
/// <para>SDL_HapticRumblePlay</para>
/// <para>SDL_HapticRumbleStop</para>
/// </remarks>
        public static int HapticRumbleInit(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticRumbleInit(__arg0);
            return __ret;
        }

        /// <summary>Runs simple rumble on a haptic device</summary>
/// <param name="haptic">Haptic device to play rumble effect on.</param>
/// <param name="strength">Strength of the rumble to play as a 0-1 float value.</param>
/// <param name="length">Length of the rumble to play in milliseconds.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticRumbleSupported</para>
/// <para>SDL_HapticRumbleInit</para>
/// <para>SDL_HapticRumbleStop</para>
/// </remarks>
        public static int HapticRumblePlay(global::SharpSDL.SDL_Haptic haptic, float strength, uint length)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticRumblePlay(__arg0, strength, length);
            return __ret;
        }

        /// <summary>Stops the simple rumble on a haptic device.</summary>
/// <param name="haptic">Haptic to stop the rumble on.</param>
/// <returns>0 on success or -1 on error.</returns>
/// <remarks>
/// <para>SDL_HapticRumbleSupported</para>
/// <para>SDL_HapticRumbleInit</para>
/// <para>SDL_HapticRumblePlay</para>
/// </remarks>
        public static int HapticRumbleStop(global::SharpSDL.SDL_Haptic haptic)
        {
            var __arg0 = ReferenceEquals(haptic, null) ? global::System.IntPtr.Zero : haptic.__Instance;
            var __ret = __Internal.HapticRumbleStop(__arg0);
            return __ret;
        }
    }
}

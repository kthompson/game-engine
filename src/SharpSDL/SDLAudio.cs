// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SharpSDL
{
    public enum AudioStatus
    {
        AUDIO_STOPPED = 0,
        AUDIO_PLAYING = 1,
        AUDIO_PAUSED = 2
    }

    /// <summary>Audio format flags.</summary>
/// <remarks>
/// <para>These are what the 16 bits in SDL_AudioFormat currently mean...</para>
/// <para>(Unspecified bits are always zero).</para>
/// <para>There are macros in SDL 2.0 and later to query these bits.</para>
/// </remarks>
    /// <summary>This function is called when the audio device needs more data.</summary>
/// <param name="userdata">
/// <para>An application-specific parameter saved in</para>
/// <para>the SDL_AudioSpec structure</para>
/// </param>
/// <param name="stream">A pointer to the audio data buffer.</param>
/// <param name="len">The length of that buffer in bytes.</param>
/// <remarks>
/// <para>Once the callback returns, the buffer will no longer be valid.</para>
/// <para>Stereo samples are stored in a LRLRLR ordering.</para>
/// <para>You can choose to avoid callbacks and use SDL_QueueAudio() instead, if</para>
/// <para>you like. Just open your audio device with a NULL callback.</para>
/// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void AudioCallback(global::System.IntPtr userdata, byte* stream, int len);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void AudioFilter(global::System.IntPtr cvt, ushort format);

    /// <summary>SDL Audio Device IDs.</summary>
/// <remarks>
/// <para>A successful call to SDL_OpenAudio() is always device id 1, and legacy</para>
/// <para>SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls</para>
/// <para>always returns devices &gt;= 2 on success. The legacy calls are good both</para>
/// <para>for backwards compatibility and when you don't care about multiple,</para>
/// <para>specific, or capture devices.</para>
/// </remarks>
    public unsafe partial class SDL_AudioStream
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.SDL_AudioStream> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.SDL_AudioStream>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.SDL_AudioStream __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.SDL_AudioStream(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.SDL_AudioStream __CreateInstance(global::SharpSDL.SDL_AudioStream.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.SDL_AudioStream(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.SDL_AudioStream.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.SDL_AudioStream.__Internal));
            *(global::SharpSDL.SDL_AudioStream.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SDL_AudioStream(global::SharpSDL.SDL_AudioStream.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SDL_AudioStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>The calculated values in this structure are calculated by SDL_OpenAudio().</summary>
/// <remarks>
/// <para>For multi-channel audio, the default SDL channel mapping is:</para>
/// <para>2:  FL FR                       (stereo)</para>
/// <para>3:  FL FR LFE                   (2.1 surround)</para>
/// <para>4:  FL FR BL BR                 (quad)</para>
/// <para>5:  FL FR FC BL BR              (quad + center)</para>
/// <para>6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)</para>
/// <para>7:  FL FR FC LFE BC SL SR       (6.1 surround)</para>
/// <para>8:  FL FR FC LFE BL BR SL SR    (7.1 surround)</para>
/// </remarks>
    public unsafe partial class AudioSpec : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int freq;

            [FieldOffset(4)]
            internal ushort format;

            [FieldOffset(6)]
            internal byte channels;

            [FieldOffset(7)]
            internal byte silence;

            [FieldOffset(8)]
            internal ushort samples;

            [FieldOffset(10)]
            internal ushort padding;

            [FieldOffset(12)]
            internal uint size;

            [FieldOffset(16)]
            internal global::System.IntPtr callback;

            [FieldOffset(24)]
            internal global::System.IntPtr userdata;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_AudioSpec@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.AudioSpec> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.AudioSpec>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.AudioSpec __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.AudioSpec(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.AudioSpec __CreateInstance(global::SharpSDL.AudioSpec.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.AudioSpec(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.AudioSpec.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AudioSpec.__Internal));
            *(global::SharpSDL.AudioSpec.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioSpec(global::SharpSDL.AudioSpec.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AudioSpec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AudioSpec()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AudioSpec.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AudioSpec(global::SharpSDL.AudioSpec _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AudioSpec.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.AudioSpec.__Internal*) __Instance) = *((global::SharpSDL.AudioSpec.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.AudioSpec __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Freq
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->freq;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->freq = value;
            }
        }

        public ushort Format
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->format;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->format = value;
            }
        }

        public byte Channels
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->channels;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->channels = value;
            }
        }

        public byte Silence
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->silence;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->silence = value;
            }
        }

        public ushort Samples
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->samples;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->samples = value;
            }
        }

        public ushort Padding
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->padding;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->padding = value;
            }
        }

        public uint Size
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->size;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->size = value;
            }
        }

        public global::SharpSDL.AudioCallback Callback
        {
            get
            {
                var __ptr0 = ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::SharpSDL.AudioCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SharpSDL.AudioCallback));
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr Userdata
        {
            get
            {
                return ((global::SharpSDL.AudioSpec.__Internal*) __Instance)->userdata;
            }

            set
            {
                ((global::SharpSDL.AudioSpec.__Internal*)__Instance)->userdata = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class AudioCVT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int needed;

            [FieldOffset(4)]
            internal ushort src_format;

            [FieldOffset(6)]
            internal ushort dst_format;

            [FieldOffset(8)]
            internal double rate_incr;

            [FieldOffset(16)]
            internal global::System.IntPtr buf;

            [FieldOffset(24)]
            internal int len;

            [FieldOffset(28)]
            internal int len_cvt;

            [FieldOffset(32)]
            internal int len_mult;

            [FieldOffset(40)]
            internal double len_ratio;

            [FieldOffset(48)]
            internal fixed long filters[10];

            [FieldOffset(128)]
            internal int filter_index;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_AudioCVT@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.AudioCVT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.AudioCVT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.AudioCVT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.AudioCVT(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.AudioCVT __CreateInstance(global::SharpSDL.AudioCVT.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.AudioCVT(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.AudioCVT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AudioCVT.__Internal));
            *(global::SharpSDL.AudioCVT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioCVT(global::SharpSDL.AudioCVT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AudioCVT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AudioCVT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AudioCVT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AudioCVT(global::SharpSDL.AudioCVT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AudioCVT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.AudioCVT.__Internal*) __Instance) = *((global::SharpSDL.AudioCVT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.AudioCVT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Needed
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->needed;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->needed = value;
            }
        }

        public ushort SrcFormat
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->src_format;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->src_format = value;
            }
        }

        public ushort DstFormat
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->dst_format;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->dst_format = value;
            }
        }

        public double RateIncr
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->rate_incr;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->rate_incr = value;
            }
        }

        public byte* Buf
        {
            get
            {
                return (byte*) ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->buf;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->buf = (global::System.IntPtr) value;
            }
        }

        public int Len
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->len;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->len = value;
            }
        }

        public int LenCvt
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->len_cvt;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->len_cvt = value;
            }
        }

        public int LenMult
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->len_mult;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->len_mult = value;
            }
        }

        public double LenRatio
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->len_ratio;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->len_ratio = value;
            }
        }

        public int FilterIndex
        {
            get
            {
                return ((global::SharpSDL.AudioCVT.__Internal*) __Instance)->filter_index;
            }

            set
            {
                ((global::SharpSDL.AudioCVT.__Internal*)__Instance)->filter_index = value;
            }
        }
    }

    public unsafe partial class SDL_audio
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetNumAudioDrivers")]
            internal static extern int GetNumAudioDrivers();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetAudioDriver")]
            internal static extern global::System.IntPtr GetAudioDriver(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_AudioInit")]
            internal static extern int AudioInit([MarshalAs(UnmanagedType.LPStr)] string driver_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_AudioQuit")]
            internal static extern void AudioQuit();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetCurrentAudioDriver")]
            internal static extern global::System.IntPtr GetCurrentAudioDriver();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_OpenAudio")]
            internal static extern int OpenAudio(global::System.IntPtr desired, global::System.IntPtr obtained);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetNumAudioDevices")]
            internal static extern int GetNumAudioDevices(int iscapture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetAudioDeviceName")]
            internal static extern global::System.IntPtr GetAudioDeviceName(int index, int iscapture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_OpenAudioDevice")]
            internal static extern uint OpenAudioDevice([MarshalAs(UnmanagedType.LPStr)] string device, int iscapture, global::System.IntPtr desired, global::System.IntPtr obtained, int allowed_changes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetAudioStatus")]
            internal static extern global::SharpSDL.AudioStatus GetAudioStatus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetAudioDeviceStatus")]
            internal static extern global::SharpSDL.AudioStatus GetAudioDeviceStatus(uint dev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_PauseAudio")]
            internal static extern void PauseAudio(int pause_on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_PauseAudioDevice")]
            internal static extern void PauseAudioDevice(uint dev, int pause_on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_FreeWAV")]
            internal static extern void FreeWAV(byte* audio_buf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_BuildAudioCVT")]
            internal static extern int BuildAudioCVT(global::System.IntPtr cvt, ushort src_format, byte src_channels, int src_rate, ushort dst_format, byte dst_channels, int dst_rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ConvertAudio")]
            internal static extern int ConvertAudio(global::System.IntPtr cvt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_NewAudioStream")]
            internal static extern global::System.IntPtr NewAudioStream(ushort src_format, byte src_channels, int src_rate, ushort dst_format, byte dst_channels, int dst_rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_AudioStreamPut")]
            internal static extern int AudioStreamPut(global::System.IntPtr stream, global::System.IntPtr buf, int len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_AudioStreamGet")]
            internal static extern int AudioStreamGet(global::System.IntPtr stream, global::System.IntPtr buf, int len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_AudioStreamAvailable")]
            internal static extern int AudioStreamAvailable(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_AudioStreamFlush")]
            internal static extern int AudioStreamFlush(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_AudioStreamClear")]
            internal static extern void AudioStreamClear(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_FreeAudioStream")]
            internal static extern void FreeAudioStream(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_MixAudio")]
            internal static extern void MixAudio(byte* dst, byte* src, uint len, int volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_MixAudioFormat")]
            internal static extern void MixAudioFormat(byte* dst, byte* src, ushort format, uint len, int volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_QueueAudio")]
            internal static extern int QueueAudio(uint dev, global::System.IntPtr data, uint len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_DequeueAudio")]
            internal static extern uint DequeueAudio(uint dev, global::System.IntPtr data, uint len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetQueuedAudioSize")]
            internal static extern uint GetQueuedAudioSize(uint dev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ClearQueuedAudio")]
            internal static extern void ClearQueuedAudio(uint dev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_LockAudio")]
            internal static extern void LockAudio();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_LockAudioDevice")]
            internal static extern void LockAudioDevice(uint dev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UnlockAudio")]
            internal static extern void UnlockAudio();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UnlockAudioDevice")]
            internal static extern void UnlockAudioDevice(uint dev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CloseAudio")]
            internal static extern void CloseAudio();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CloseAudioDevice")]
            internal static extern void CloseAudioDevice(uint dev);
        }

        public static int GetNumAudioDrivers()
        {
            var __ret = __Internal.GetNumAudioDrivers();
            return __ret;
        }

        public static string GetAudioDriver(int index)
        {
            var __ret = __Internal.GetAudioDriver(index);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static int AudioInit(string driver_name)
        {
            var __ret = __Internal.AudioInit(driver_name);
            return __ret;
        }

        public static void AudioQuit()
        {
            __Internal.AudioQuit();
        }

        /// <summary>
/// <para>This function returns the name of the current audio driver, or NULL</para>
/// <para>if no driver has been initialized.</para>
/// </summary>
        public static string GetCurrentAudioDriver()
        {
            var __ret = __Internal.GetCurrentAudioDriver();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
/// <para>This function opens the audio device with the desired parameters, and</para>
/// <para>returns 0 if successful, placing the actual hardware parameters in the</para>
/// <para>structure pointed to byIfis NULL, the audio</para>
/// <para>data passed to the callback function will be guaranteed to be in the</para>
/// <para>requested format, and will be automatically converted to the hardware</para>
/// <para>audio format if necessary.  This function returns -1 if it failed</para>
/// <para>to open the audio device, or couldn't set up the audio thread.</para>
/// </summary>
/// <remarks>
/// <para>When filling in the desired audio spec structure,</para>
/// <para>-should be the desired audio frequency in samples-per-</para>
/// <para>second.</para>
/// <para>-should be the desired audio format.</para>
/// <para>-is the desired size of the audio buffer, in</para>
/// <para>samples.  This number should be a power of two, and may be adjusted by</para>
/// <para>the audio driver to a value more suitable for the hardware.  Good values</para>
/// <para>seem to range between 512 and 8096 inclusive, depending on the</para>
/// <para>application and CPU speed.  Smaller values yield faster response time,</para>
/// <para>but can lead to underflow if the application is doing heavy processing</para>
/// <para>and cannot fill the audio buffer in time.  A stereo sample consists of</para>
/// <para>both right and left channels in LR ordering.</para>
/// <para>Note that the number of samples is directly related to time by the</para>
/// <para>following formula:</para>
/// <para>-is the size in bytes of the audio buffer, and is</para>
/// <para>calculated by SDL_OpenAudio().</para>
/// <para>-is the value used to set the buffer to silence,</para>
/// <para>and is calculated by SDL_OpenAudio().</para>
/// <para>-should be set to a function that will be called</para>
/// <para>when the audio device is ready for more data.  It is passed a pointer</para>
/// <para>to the audio buffer, and the length in bytes of the audio buffer.</para>
/// <para>This function usually runs in a separate thread, and so you should</para>
/// <para>protect data structures that it accesses by calling SDL_LockAudio()</para>
/// <para>and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL</para>
/// <para>pointer here, and call SDL_QueueAudio() with some frequency, to queue</para>
/// <para>more audio samples to be played (or for capture devices, call</para>
/// <para>SDL_DequeueAudio() with some frequency, to obtain audio samples).</para>
/// <para>-is passed as the first parameter to your callback</para>
/// <para>function. If you passed a NULL callback, this value is ignored.</para>
/// <para>The audio device starts out playing silence when it's opened, and should</para>
/// <para>be enabled for playing by callingwhen you are ready</para>
/// <para>for your audio callback function to be called.  Since the audio driver</para>
/// <para>may modify the requested size of the audio buffer, you should allocate</para>
/// <para>any local mixing buffers after you open the audio device.</para>
/// </remarks>
        public static int OpenAudio(global::SharpSDL.AudioSpec desired, global::SharpSDL.AudioSpec obtained)
        {
            var __arg0 = ReferenceEquals(desired, null) ? global::System.IntPtr.Zero : desired.__Instance;
            var __arg1 = ReferenceEquals(obtained, null) ? global::System.IntPtr.Zero : obtained.__Instance;
            var __ret = __Internal.OpenAudio(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
/// <para>Get the number of available devices exposed by the current driver.</para>
/// <para>Only valid after a successfully initializing the audio subsystem.</para>
/// <para>Returns -1 if an explicit list of devices can't be determined; this is</para>
/// <para>not an error. For example, if SDL is set up to talk to a remote audio</para>
/// <para>server, it can't list every one available on the Internet, but it will</para>
/// <para>still allow a specific host to be specified to SDL_OpenAudioDevice().</para>
/// </summary>
/// <remarks>
/// <para>In many common cases, when this function returns a value&lt;&gt;= 0, it can still</para>
/// <para>successfully open the default device (NULL for first argument of</para>
/// <para>SDL_OpenAudioDevice()).</para>
/// </remarks>
        public static int GetNumAudioDevices(int iscapture)
        {
            var __ret = __Internal.GetNumAudioDevices(iscapture);
            return __ret;
        }

        /// <summary>
/// <para>Get the human-readable name of a specific audio device.</para>
/// <para>Must be a value between 0 and (number of audio devices-1).</para>
/// <para>Only valid after a successfully initializing the audio subsystem.</para>
/// <para>The values returned by this function reflect the latest call to</para>
/// <para>SDL_GetNumAudioDevices(); recall that function to redetect available</para>
/// <para>hardware.</para>
/// </summary>
/// <remarks>
/// <para>The string returned by this function is UTF-8 encoded, read-only, and</para>
/// <para>managed internally. You are not to free it. If you need to keep the</para>
/// <para>string for any length of time, you should make your own copy of it, as it</para>
/// <para>will be invalid next time any of several other SDL functions is called.</para>
/// </remarks>
        public static string GetAudioDeviceName(int index, int iscapture)
        {
            var __ret = __Internal.GetAudioDeviceName(index, iscapture);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
/// <para>Open a specific audio device. Passing in a device name of NULL requests</para>
/// <para>the most reasonable default (and is equivalent to calling SDL_OpenAudio()).</para>
/// </summary>
/// <returns>
/// <para>0 on error, a valid device ID that is &gt;= 2 on success.</para>
/// <para>SDL_OpenAudio(), unlike this function, always acts on device ID 1.</para>
/// </returns>
/// <remarks>
/// <para>The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but</para>
/// <para>some drivers allow arbitrary and driver-specific strings, such as a</para>
/// <para>hostname/IP address for a remote audio server, or a filename in the</para>
/// <para>diskaudio driver.</para>
/// </remarks>
        public static uint OpenAudioDevice(string device, int iscapture, global::SharpSDL.AudioSpec desired, global::SharpSDL.AudioSpec obtained, int allowed_changes)
        {
            var __arg2 = ReferenceEquals(desired, null) ? global::System.IntPtr.Zero : desired.__Instance;
            var __arg3 = ReferenceEquals(obtained, null) ? global::System.IntPtr.Zero : obtained.__Instance;
            var __ret = __Internal.OpenAudioDevice(device, iscapture, __arg2, __arg3, allowed_changes);
            return __ret;
        }

        public static global::SharpSDL.AudioStatus GetAudioStatus()
        {
            var __ret = __Internal.GetAudioStatus();
            return __ret;
        }

        public static global::SharpSDL.AudioStatus GetAudioDeviceStatus(uint dev)
        {
            var __ret = __Internal.GetAudioDeviceStatus(dev);
            return __ret;
        }

        public static void PauseAudio(int pause_on)
        {
            __Internal.PauseAudio(pause_on);
        }

        public static void PauseAudioDevice(uint dev, int pause_on)
        {
            __Internal.PauseAudioDevice(dev, pause_on);
        }

        /// <summary>This function frees data previously allocated with SDL_LoadWAV_RW()</summary>
        public static void FreeWAV(byte* audio_buf)
        {
            __Internal.FreeWAV(audio_buf);
        }

        /// <summary>
/// <para>This function takes a source format and rate and a destination format</para>
/// <para>and rate, and initializes thestructure with information needed</para>
/// <para>by SDL_ConvertAudio() to convert a buffer of audio data from one format</para>
/// <para>to the other. An unsupported format causes an error and -1 will be returned.</para>
/// </summary>
/// <returns>
/// <para>0 if no conversion is needed, 1 if the audio filter is set up,</para>
/// <para>or -1 on error.</para>
/// </returns>
        public static int BuildAudioCVT(global::SharpSDL.AudioCVT cvt, ushort src_format, byte src_channels, int src_rate, ushort dst_format, byte dst_channels, int dst_rate)
        {
            var __arg0 = ReferenceEquals(cvt, null) ? global::System.IntPtr.Zero : cvt.__Instance;
            var __ret = __Internal.BuildAudioCVT(__arg0, src_format, src_channels, src_rate, dst_format, dst_channels, dst_rate);
            return __ret;
        }

        /// <summary>
/// <para>Once you have initialized thestructure using SDL_BuildAudioCVT(),</para>
/// <para>created an audio bufferand filled it withbytes of</para>
/// <para>audio data in the source format, this function will convert it in-place</para>
/// <para>to the desired format.</para>
/// </summary>
/// <returns>0 on success or -1 ifis NULL.</returns>
/// <remarks>
/// <para>The data conversion may expand the size of the audio data, so the buffer</para>
/// <para>should be allocated after thestructure is initialized by</para>
/// <para>SDL_BuildAudioCVT(), and should bebytes long.</para>
/// </remarks>
        public static int ConvertAudio(global::SharpSDL.AudioCVT cvt)
        {
            var __arg0 = ReferenceEquals(cvt, null) ? global::System.IntPtr.Zero : cvt.__Instance;
            var __ret = __Internal.ConvertAudio(__arg0);
            return __ret;
        }

        /// <summary>Create a new audio stream</summary>
/// <param name="src_format">The format of the source audio</param>
/// <param name="src_channels">The number of channels of the source audio</param>
/// <param name="src_rate">The sampling rate of the source audio</param>
/// <param name="dst_format">The format of the desired audio output</param>
/// <param name="dst_channels">The number of channels of the desired audio output</param>
/// <param name="dst_rate">The sampling rate of the desired audio output</param>
/// <returns>0 on success, or -1 on error.</returns>
/// <remarks>
/// <para>SDL_AudioStreamPut</para>
/// <para>SDL_AudioStreamGet</para>
/// <para>SDL_AudioStreamAvailable</para>
/// <para>SDL_AudioStreamFlush</para>
/// <para>SDL_AudioStreamClear</para>
/// <para>SDL_FreeAudioStream</para>
/// </remarks>
        public static global::SharpSDL.SDL_AudioStream NewAudioStream(ushort src_format, byte src_channels, int src_rate, ushort dst_format, byte dst_channels, int dst_rate)
        {
            var __ret = __Internal.NewAudioStream(src_format, src_channels, src_rate, dst_format, dst_channels, dst_rate);
            global::SharpSDL.SDL_AudioStream __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.SDL_AudioStream.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.SDL_AudioStream) global::SharpSDL.SDL_AudioStream.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.SDL_AudioStream.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Add data to be converted/resampled to the stream</summary>
/// <param name="stream">The stream the audio data is being added to</param>
/// <param name="buf">A pointer to the audio data to add</param>
/// <param name="len">The number of bytes to write to the stream</param>
/// <returns>0 on success, or -1 on error.</returns>
/// <remarks>
/// <para>SDL_NewAudioStream</para>
/// <para>SDL_AudioStreamGet</para>
/// <para>SDL_AudioStreamAvailable</para>
/// <para>SDL_AudioStreamFlush</para>
/// <para>SDL_AudioStreamClear</para>
/// <para>SDL_FreeAudioStream</para>
/// </remarks>
        public static int AudioStreamPut(global::SharpSDL.SDL_AudioStream stream, global::System.IntPtr buf, int len)
        {
            var __arg0 = ReferenceEquals(stream, null) ? global::System.IntPtr.Zero : stream.__Instance;
            var __ret = __Internal.AudioStreamPut(__arg0, buf, len);
            return __ret;
        }

        /// <summary>Get converted/resampled data from the stream</summary>
/// <param name="stream">The stream the audio is being requested from</param>
/// <param name="buf">A buffer to fill with audio data</param>
/// <param name="len">The maximum number of bytes to fill</param>
/// <returns>The number of bytes read from the stream, or -1 on error</returns>
/// <remarks>
/// <para>SDL_NewAudioStream</para>
/// <para>SDL_AudioStreamPut</para>
/// <para>SDL_AudioStreamAvailable</para>
/// <para>SDL_AudioStreamFlush</para>
/// <para>SDL_AudioStreamClear</para>
/// <para>SDL_FreeAudioStream</para>
/// </remarks>
        public static int AudioStreamGet(global::SharpSDL.SDL_AudioStream stream, global::System.IntPtr buf, int len)
        {
            var __arg0 = ReferenceEquals(stream, null) ? global::System.IntPtr.Zero : stream.__Instance;
            var __ret = __Internal.AudioStreamGet(__arg0, buf, len);
            return __ret;
        }

        /// <summary>
/// <para>Get the number of converted/resampled bytes available. The stream may be</para>
/// <para>buffering data behind the scenes until it has enough to resample</para>
/// <para>correctly, so this number might be lower than what you expect, or even</para>
/// <para>be zero. Add more data or flush the stream if you need the data now.</para>
/// </summary>
/// <remarks>
/// <para>SDL_NewAudioStream</para>
/// <para>SDL_AudioStreamPut</para>
/// <para>SDL_AudioStreamGet</para>
/// <para>SDL_AudioStreamFlush</para>
/// <para>SDL_AudioStreamClear</para>
/// <para>SDL_FreeAudioStream</para>
/// </remarks>
        public static int AudioStreamAvailable(global::SharpSDL.SDL_AudioStream stream)
        {
            var __arg0 = ReferenceEquals(stream, null) ? global::System.IntPtr.Zero : stream.__Instance;
            var __ret = __Internal.AudioStreamAvailable(__arg0);
            return __ret;
        }

        /// <summary>
/// <para>Tell the stream that you're done sending data, and anything being buffered</para>
/// <para>should be converted/resampled and made available immediately.</para>
/// </summary>
/// <remarks>
/// <para>It is legal to add more data to a stream after flushing, but there will</para>
/// <para>be audio gaps in the output. Generally this is intended to signal the</para>
/// <para>end of input, so the complete output becomes available.</para>
/// <para>SDL_NewAudioStream</para>
/// <para>SDL_AudioStreamPut</para>
/// <para>SDL_AudioStreamGet</para>
/// <para>SDL_AudioStreamAvailable</para>
/// <para>SDL_AudioStreamClear</para>
/// <para>SDL_FreeAudioStream</para>
/// </remarks>
        public static int AudioStreamFlush(global::SharpSDL.SDL_AudioStream stream)
        {
            var __arg0 = ReferenceEquals(stream, null) ? global::System.IntPtr.Zero : stream.__Instance;
            var __ret = __Internal.AudioStreamFlush(__arg0);
            return __ret;
        }

        /// <summary>Clear any pending data in the stream without converting it</summary>
/// <remarks>
/// <para>SDL_NewAudioStream</para>
/// <para>SDL_AudioStreamPut</para>
/// <para>SDL_AudioStreamGet</para>
/// <para>SDL_AudioStreamAvailable</para>
/// <para>SDL_AudioStreamFlush</para>
/// <para>SDL_FreeAudioStream</para>
/// </remarks>
        public static void AudioStreamClear(global::SharpSDL.SDL_AudioStream stream)
        {
            var __arg0 = ReferenceEquals(stream, null) ? global::System.IntPtr.Zero : stream.__Instance;
            __Internal.AudioStreamClear(__arg0);
        }

        /// <summary>Free an audio stream</summary>
/// <remarks>
/// <para>SDL_NewAudioStream</para>
/// <para>SDL_AudioStreamPut</para>
/// <para>SDL_AudioStreamGet</para>
/// <para>SDL_AudioStreamAvailable</para>
/// <para>SDL_AudioStreamFlush</para>
/// <para>SDL_AudioStreamClear</para>
/// </remarks>
        public static void FreeAudioStream(global::SharpSDL.SDL_AudioStream stream)
        {
            var __arg0 = ReferenceEquals(stream, null) ? global::System.IntPtr.Zero : stream.__Instance;
            __Internal.FreeAudioStream(__arg0);
        }

        /// <summary>
/// <para>This takes two audio buffers of the playing audio format and mixes</para>
/// <para>them, performing addition, volume adjustment, and overflow clipping.</para>
/// <para>The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME</para>
/// <para>for full audio volume.  Note this does not change hardware volume.</para>
/// <para>This is provided for convenience -- you can mix your own audio data.</para>
/// </summary>
        public static void MixAudio(byte* dst, byte* src, uint len, int volume)
        {
            __Internal.MixAudio(dst, src, len, volume);
        }

        /// <summary>
/// <para>This works like SDL_MixAudio(), but you specify the audio format instead of</para>
/// <para>using the format of audio device 1. Thus it can be used when no audio</para>
/// <para>device is open at all.</para>
/// </summary>
        public static void MixAudioFormat(byte* dst, byte* src, ushort format, uint len, int volume)
        {
            __Internal.MixAudioFormat(dst, src, format, len, volume);
        }

        /// <summary>Queue more audio on non-callback devices.</summary>
/// <param name="dev">The device ID to which we will queue audio.</param>
/// <param name="data">The data to queue to the device for later playback.</param>
/// <param name="len">The number of bytes (not samples!) to which (data) points.</param>
/// <returns>0 on success, or -1 on error.</returns>
/// <remarks>
/// <para>(If you are looking to retrieve queued audio from a non-callback capture</para>
/// <para>device, you want SDL_DequeueAudio() instead. This will return -1 to</para>
/// <para>signify an error if you use it with capture devices.)</para>
/// <para>SDL offers two ways to feed audio to the device: you can either supply a</para>
/// <para>callback that SDL triggers with some frequency to obtain more audio</para>
/// <para>(pull method), or you can supply no callback, and then SDL will expect</para>
/// <para>you to supply data at regular intervals (push method) with this function.</para>
/// <para>There are no limits on the amount of data you can queue, short of</para>
/// <para>exhaustion of address space. Queued data will drain to the device as</para>
/// <para>necessary without further intervention from you. If the device needs</para>
/// <para>audio but there is not enough queued, it will play silence to make up</para>
/// <para>the difference. This means you will have skips in your audio playback</para>
/// <para>if you aren't routinely queueing sufficient data.</para>
/// <para>This function copies the supplied data, so you are safe to free it when</para>
/// <para>the function returns. This function is thread-safe, but queueing to the</para>
/// <para>same device from two threads at once does not promise which buffer will</para>
/// <para>be queued first.</para>
/// <para>You may not queue audio on a device that is using an application-supplied</para>
/// <para>callback; doing so returns an error. You have to use the audio callback</para>
/// <para>or queue audio with this function, but not both.</para>
/// <para>You should not call SDL_LockAudio() on the device before queueing; SDL</para>
/// <para>handles locking internally for this function.</para>
/// <para>SDL_GetQueuedAudioSize</para>
/// <para>SDL_ClearQueuedAudio</para>
/// </remarks>
        public static int QueueAudio(uint dev, global::System.IntPtr data, uint len)
        {
            var __ret = __Internal.QueueAudio(dev, data, len);
            return __ret;
        }

        /// <summary>Dequeue more audio on non-callback devices.</summary>
/// <param name="dev">The device ID from which we will dequeue audio.</param>
/// <param name="data">A pointer into where audio data should be copied.</param>
/// <param name="len">The number of bytes (not samples!) to which (data) points.</param>
/// <returns>number of bytes dequeued, which could be less than requested.</returns>
/// <remarks>
/// <para>(If you are looking to queue audio for output on a non-callback playback</para>
/// <para>device, you want SDL_QueueAudio() instead. This will always return 0</para>
/// <para>if you use it with playback devices.)</para>
/// <para>SDL offers two ways to retrieve audio from a capture device: you can</para>
/// <para>either supply a callback that SDL triggers with some frequency as the</para>
/// <para>device records more audio data, (push method), or you can supply no</para>
/// <para>callback, and then SDL will expect you to retrieve data at regular</para>
/// <para>intervals (pull method) with this function.</para>
/// <para>There are no limits on the amount of data you can queue, short of</para>
/// <para>exhaustion of address space. Data from the device will keep queuing as</para>
/// <para>necessary without further intervention from you. This means you will</para>
/// <para>eventually run out of memory if you aren't routinely dequeueing data.</para>
/// <para>Capture devices will not queue data when paused; if you are expecting</para>
/// <para>to not need captured audio for some length of time, use</para>
/// <para>SDL_PauseAudioDevice() to stop the capture device from queueing more</para>
/// <para>data. This can be useful during, say, level loading times. When</para>
/// <para>unpaused, capture devices will start queueing data from that point,</para>
/// <para>having flushed any capturable data available while paused.</para>
/// <para>This function is thread-safe, but dequeueing from the same device from</para>
/// <para>two threads at once does not promise which thread will dequeued data</para>
/// <para>first.</para>
/// <para>You may not dequeue audio from a device that is using an</para>
/// <para>application-supplied callback; doing so returns an error. You have to use</para>
/// <para>the audio callback, or dequeue audio with this function, but not both.</para>
/// <para>You should not call SDL_LockAudio() on the device before queueing; SDL</para>
/// <para>handles locking internally for this function.</para>
/// <para>SDL_GetQueuedAudioSize</para>
/// <para>SDL_ClearQueuedAudio</para>
/// </remarks>
        public static uint DequeueAudio(uint dev, global::System.IntPtr data, uint len)
        {
            var __ret = __Internal.DequeueAudio(dev, data, len);
            return __ret;
        }

        /// <summary>Get the number of bytes of still-queued audio.</summary>
/// <param name="dev">The device ID of which we will query queued audio size.</param>
/// <returns>Number of bytes (not samples!) of queued audio.</returns>
/// <remarks>
/// <para>For playback device:</para>
/// <para>This is the number of bytes that have been queued for playback with</para>
/// <para>SDL_QueueAudio(), but have not yet been sent to the hardware. This</para>
/// <para>number may shrink at any time, so this only informs of pending data.</para>
/// <para>Once we've sent it to the hardware, this function can not decide the</para>
/// <para>exact byte boundary of what has been played. It's possible that we just</para>
/// <para>gave the hardware several kilobytes right before you called this</para>
/// <para>function, but it hasn't played any of it yet, or maybe half of it, etc.</para>
/// <para>For capture devices:</para>
/// <para>This is the number of bytes that have been captured by the device and</para>
/// <para>are waiting for you to dequeue. This number may grow at any time, so</para>
/// <para>this only informs of the lower-bound of available data.</para>
/// <para>You may not queue audio on a device that is using an application-supplied</para>
/// <para>callback; calling this function on such a device always returns 0.</para>
/// <para>You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use</para>
/// <para>the audio callback, but not both.</para>
/// <para>You should not call SDL_LockAudio() on the device before querying; SDL</para>
/// <para>handles locking internally for this function.</para>
/// <para>SDL_QueueAudio</para>
/// <para>SDL_ClearQueuedAudio</para>
/// </remarks>
        public static uint GetQueuedAudioSize(uint dev)
        {
            var __ret = __Internal.GetQueuedAudioSize(dev);
            return __ret;
        }

        /// <summary>
/// <para>Drop any queued audio data. For playback devices, this is any queued data</para>
/// <para>still waiting to be submitted to the hardware. For capture devices, this</para>
/// <para>is any data that was queued by the device that hasn't yet been dequeued by</para>
/// <para>the application.</para>
/// </summary>
/// <param name="dev">The device ID of which to clear the audio queue.</param>
/// <remarks>
/// <para>Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For</para>
/// <para>playback devices, the hardware will start playing silence if more audio</para>
/// <para>isn't queued. Unpaused capture devices will start filling the queue again</para>
/// <para>as soon as they have more data available (which, depending on the state</para>
/// <para>of the hardware and the thread, could be before this function call</para>
/// <para>returns!).</para>
/// <para>This will not prevent playback of queued audio that's already been sent</para>
/// <para>to the hardware, as we can not undo that, so expect there to be some</para>
/// <para>fraction of a second of audio that might still be heard. This can be</para>
/// <para>useful if you want to, say, drop any pending music during a level change</para>
/// <para>in your game.</para>
/// <para>You may not queue audio on a device that is using an application-supplied</para>
/// <para>callback; calling this function on such a device is always a no-op.</para>
/// <para>You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use</para>
/// <para>the audio callback, but not both.</para>
/// <para>You should not call SDL_LockAudio() on the device before clearing the</para>
/// <para>queue; SDL handles locking internally for this function.</para>
/// <para>This function always succeeds and thus returns void.</para>
/// <para>SDL_QueueAudio</para>
/// <para>SDL_GetQueuedAudioSize</para>
/// </remarks>
        public static void ClearQueuedAudio(uint dev)
        {
            __Internal.ClearQueuedAudio(dev);
        }

        public static void LockAudio()
        {
            __Internal.LockAudio();
        }

        public static void LockAudioDevice(uint dev)
        {
            __Internal.LockAudioDevice(dev);
        }

        public static void UnlockAudio()
        {
            __Internal.UnlockAudio();
        }

        public static void UnlockAudioDevice(uint dev)
        {
            __Internal.UnlockAudioDevice(dev);
        }

        /// <summary>This function shuts down audio processing and closes the audio device.</summary>
        public static void CloseAudio()
        {
            __Internal.CloseAudio();
        }

        public static void CloseAudioDevice(uint dev)
        {
            __Internal.CloseAudioDevice(dev);
        }
    }
}

// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SharpSDL
{
    /// <summary>The flags on a window</summary>
/// <remarks>SDL_GetWindowFlags()</remarks>
    public enum WindowFlags
    {
        /// <summary>fullscreen window</summary>
        WINDOW_FULLSCREEN = 1,
        /// <summary>window usable with OpenGL context</summary>
        WINDOW_OPENGL = 2,
        /// <summary>window is visible</summary>
        WINDOW_SHOWN = 4,
        /// <summary>window is not visible</summary>
        WINDOW_HIDDEN = 8,
        /// <summary>no window decoration</summary>
        WINDOW_BORDERLESS = 16,
        /// <summary>window can be resized</summary>
        WINDOW_RESIZABLE = 32,
        /// <summary>window is minimized</summary>
        WINDOW_MINIMIZED = 64,
        /// <summary>window is maximized</summary>
        WINDOW_MAXIMIZED = 128,
        /// <summary>window has grabbed input focus</summary>
        WINDOW_INPUT_GRABBED = 256,
        /// <summary>window has input focus</summary>
        WINDOW_INPUT_FOCUS = 512,
        /// <summary>window has mouse focus</summary>
        WINDOW_MOUSE_FOCUS = 1024,
        WINDOW_FULLSCREEN_DESKTOP = 4097,
        /// <summary>window not created by SDL</summary>
        WINDOW_FOREIGN = 2048,
        /// <summary>
/// <para>window should be created in high-DPI mode if supported.</para>
/// <para>On macOS NSHighResolutionCapable must be set true in the</para>
/// <para>application's Info.plist for this to have any effect.</para>
/// </summary>
        WINDOW_ALLOW_HIGHDPI = 8192,
        /// <summary>window has mouse captured (unrelated to INPUT_GRABBED)</summary>
        WINDOW_MOUSE_CAPTURE = 16384,
        /// <summary>window should always be above others</summary>
        WINDOW_ALWAYS_ON_TOP = 32768,
        /// <summary>window should not be added to the taskbar</summary>
        WINDOW_SKIP_TASKBAR = 65536,
        /// <summary>window should be treated as a utility window</summary>
        WINDOW_UTILITY = 131072,
        /// <summary>window should be treated as a tooltip</summary>
        WINDOW_TOOLTIP = 262144,
        /// <summary>window should be treated as a popup menu</summary>
        WINDOW_POPUP_MENU = 524288,
        /// <summary>window usable for Vulkan surface</summary>
        WINDOW_VULKAN = 268435456
    }

    /// <summary>Event subtype for window events</summary>
    public enum WindowEventID
    {
        /// <summary>Never used</summary>
        WINDOWEVENT_NONE = 0,
        /// <summary>Window has been shown</summary>
        WINDOWEVENT_SHOWN = 1,
        /// <summary>Window has been hidden</summary>
        WINDOWEVENT_HIDDEN = 2,
        /// <summary>
/// <para>Window has been exposed and should be</para>
/// <para>redrawn</para>
/// </summary>
        WINDOWEVENT_EXPOSED = 3,
        /// <summary>Window has been moved to data1, data2</summary>
        WINDOWEVENT_MOVED = 4,
        /// <summary>Window has been resized to data1xdata2</summary>
        WINDOWEVENT_RESIZED = 5,
        /// <summary>
/// <para>The window size has changed, either as</para>
/// <para>a result of an API call or through the</para>
/// <para>system or user changing the window size.</para>
/// </summary>
        WINDOWEVENT_SIZE_CHANGED = 6,
        /// <summary>Window has been minimized</summary>
        WINDOWEVENT_MINIMIZED = 7,
        /// <summary>Window has been maximized</summary>
        WINDOWEVENT_MAXIMIZED = 8,
        /// <summary>
/// <para>Window has been restored to normal size</para>
/// <para>and position</para>
/// </summary>
        WINDOWEVENT_RESTORED = 9,
        /// <summary>Window has gained mouse focus</summary>
        WINDOWEVENT_ENTER = 10,
        /// <summary>Window has lost mouse focus</summary>
        WINDOWEVENT_LEAVE = 11,
        /// <summary>Window has gained keyboard focus</summary>
        WINDOWEVENT_FOCUS_GAINED = 12,
        /// <summary>Window has lost keyboard focus</summary>
        WINDOWEVENT_FOCUS_LOST = 13,
        /// <summary>The window manager requests that the window be closed</summary>
        WINDOWEVENT_CLOSE = 14,
        /// <summary>Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)</summary>
        WINDOWEVENT_TAKE_FOCUS = 15,
        /// <summary>Window had a hit test that wasn't SDL_HITTEST_NORMAL.</summary>
        WINDOWEVENT_HIT_TEST = 16
    }

    /// <summary>Event subtype for display events</summary>
    public enum DisplayEventID
    {
        /// <summary>Never used</summary>
        DISPLAYEVENT_NONE = 0,
        /// <summary>Display orientation has changed to data1</summary>
        DISPLAYEVENT_ORIENTATION = 1
    }

    public enum DisplayOrientation
    {
        /// <summary>The display orientation can't be determined</summary>
        ORIENTATION_UNKNOWN = 0,
        /// <summary>The display is in landscape mode, with the right side up, relative to portrait mode</summary>
        ORIENTATION_LANDSCAPE = 1,
        /// <summary>The display is in landscape mode, with the left side up, relative to portrait mode</summary>
        ORIENTATION_LANDSCAPE_FLIPPED = 2,
        /// <summary>The display is in portrait mode</summary>
        ORIENTATION_PORTRAIT = 3,
        /// <summary>The display is in portrait mode, upside down</summary>
        ORIENTATION_PORTRAIT_FLIPPED = 4
    }

    /// <summary>OpenGL configuration attributes</summary>
    public enum GLattr
    {
        GL_RED_SIZE = 0,
        GL_GREEN_SIZE = 1,
        GL_BLUE_SIZE = 2,
        GL_ALPHA_SIZE = 3,
        GL_BUFFER_SIZE = 4,
        GL_DOUBLEBUFFER = 5,
        GL_DEPTH_SIZE = 6,
        GL_STENCIL_SIZE = 7,
        GL_ACCUM_RED_SIZE = 8,
        GL_ACCUM_GREEN_SIZE = 9,
        GL_ACCUM_BLUE_SIZE = 10,
        GL_ACCUM_ALPHA_SIZE = 11,
        GL_STEREO = 12,
        GL_MULTISAMPLEBUFFERS = 13,
        GL_MULTISAMPLESAMPLES = 14,
        GL_ACCELERATED_VISUAL = 15,
        GL_RETAINED_BACKING = 16,
        GL_CONTEXT_MAJOR_VERSION = 17,
        GL_CONTEXT_MINOR_VERSION = 18,
        GL_CONTEXT_EGL = 19,
        GL_CONTEXT_FLAGS = 20,
        GL_CONTEXT_PROFILE_MASK = 21,
        GL_SHARE_WITH_CURRENT_CONTEXT = 22,
        GL_FRAMEBUFFER_SRGB_CAPABLE = 23,
        GL_CONTEXT_RELEASE_BEHAVIOR = 24,
        GL_CONTEXT_RESET_NOTIFICATION = 25,
        GL_CONTEXT_NO_ERROR = 26
    }

    [Flags]
    public enum GLprofile
    {
        GL_CONTEXT_PROFILE_CORE = 1,
        GL_CONTEXT_PROFILE_COMPATIBILITY = 2,
        /// <summary>GLX_CONTEXT_ES2_PROFILE_BIT_EXT</summary>
        GL_CONTEXT_PROFILE_ES = 4
    }

    [Flags]
    public enum GLcontextFlag
    {
        GL_CONTEXT_DEBUG_FLAG = 1,
        GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2,
        GL_CONTEXT_ROBUST_ACCESS_FLAG = 4,
        GL_CONTEXT_RESET_ISOLATION_FLAG = 8
    }

    public enum GLcontextReleaseFlag
    {
        GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0,
        GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1
    }

    public enum GLContextResetNotification
    {
        GL_CONTEXT_RESET_NO_NOTIFICATION = 0,
        GL_CONTEXT_RESET_LOSE_CONTEXT = 1
    }

    /// <summary>Possible return values from the SDL_HitTest callback.</summary>
/// <remarks>SDL_HitTest</remarks>
    public enum HitTestResult
    {
        /// <summary>Region is normal. No special properties.</summary>
        HITTEST_NORMAL = 0,
        /// <summary>Region can drag entire window.</summary>
        HITTEST_DRAGGABLE = 1,
        HITTEST_RESIZE_TOPLEFT = 2,
        HITTEST_RESIZE_TOP = 3,
        HITTEST_RESIZE_TOPRIGHT = 4,
        HITTEST_RESIZE_RIGHT = 5,
        HITTEST_RESIZE_BOTTOMRIGHT = 6,
        HITTEST_RESIZE_BOTTOM = 7,
        HITTEST_RESIZE_BOTTOMLEFT = 8,
        HITTEST_RESIZE_LEFT = 9
    }

    /// <summary>The type used to identify a window</summary>
/// <remarks>
/// <para>SDL_SetWindowResizable()</para>
/// <para>SDL_SetWindowBordered()</para>
/// <para>SDL_SetWindowSize()</para>
/// <para>SDL_SetWindowPosition()</para>
/// <para>SDL_SetWindowIcon()</para>
/// <para>SDL_SetWindowGrab()</para>
/// <para>SDL_SetWindowFullscreen()</para>
/// <para>SDL_SetWindowData()</para>
/// <para>SDL_RestoreWindow()</para>
/// <para>SDL_RaiseWindow()</para>
/// <para>SDL_MinimizeWindow()</para>
/// <para>SDL_MaximizeWindow()</para>
/// <para>SDL_HideWindow()</para>
/// <para>SDL_GetWindowTitle()</para>
/// <para>SDL_GetWindowSize()</para>
/// <para>SDL_GetWindowPosition()</para>
/// <para>SDL_GetWindowGrab()</para>
/// <para>SDL_GetWindowFlags()</para>
/// <para>SDL_GetWindowData()</para>
/// <para>SDL_DestroyWindow()</para>
/// <para>SDL_CreateWindowFrom()</para>
/// <para>SDL_CreateWindow()</para>
/// <para>SDL_SetWindowTitle()</para>
/// <para>SDL_ShowWindow()</para>
/// </remarks>
    /// <summary>An opaque handle to an OpenGL context.</summary>
    /// <summary>Callback used for hit-testing.</summary>
/// <remarks>SDL_SetWindowHitTest</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::SharpSDL.HitTestResult HitTest(global::System.IntPtr win, global::System.IntPtr area, global::System.IntPtr data);

    public unsafe partial class Window
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Window> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Window>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.Window __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.Window(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.Window __CreateInstance(global::SharpSDL.Window.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.Window(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.Window.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.Window.__Internal));
            *(global::SharpSDL.Window.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Window(global::SharpSDL.Window.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Window(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>The structure that defines a display mode</summary>
/// <remarks>
/// <para>SDL_GetNumDisplayModes()</para>
/// <para>SDL_GetDisplayMode()</para>
/// <para>SDL_GetDesktopDisplayMode()</para>
/// <para>SDL_GetCurrentDisplayMode()</para>
/// <para>SDL_GetClosestDisplayMode()</para>
/// <para>SDL_SetWindowDisplayMode()</para>
/// <para>SDL_GetWindowDisplayMode()</para>
/// </remarks>
    public unsafe partial class DisplayMode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint format;

            [FieldOffset(4)]
            internal int w;

            [FieldOffset(8)]
            internal int h;

            [FieldOffset(12)]
            internal int refresh_rate;

            [FieldOffset(16)]
            internal global::System.IntPtr driverdata;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_DisplayMode@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.DisplayMode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.DisplayMode>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.DisplayMode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.DisplayMode(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.DisplayMode __CreateInstance(global::SharpSDL.DisplayMode.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.DisplayMode(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.DisplayMode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.DisplayMode.__Internal));
            *(global::SharpSDL.DisplayMode.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DisplayMode(global::SharpSDL.DisplayMode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DisplayMode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DisplayMode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.DisplayMode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public DisplayMode(global::SharpSDL.DisplayMode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.DisplayMode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.DisplayMode.__Internal*) __Instance) = *((global::SharpSDL.DisplayMode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.DisplayMode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Format
        {
            get
            {
                return ((global::SharpSDL.DisplayMode.__Internal*) __Instance)->format;
            }

            set
            {
                ((global::SharpSDL.DisplayMode.__Internal*)__Instance)->format = value;
            }
        }

        public int W
        {
            get
            {
                return ((global::SharpSDL.DisplayMode.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::SharpSDL.DisplayMode.__Internal*)__Instance)->w = value;
            }
        }

        public int H
        {
            get
            {
                return ((global::SharpSDL.DisplayMode.__Internal*) __Instance)->h;
            }

            set
            {
                ((global::SharpSDL.DisplayMode.__Internal*)__Instance)->h = value;
            }
        }

        public int RefreshRate
        {
            get
            {
                return ((global::SharpSDL.DisplayMode.__Internal*) __Instance)->refresh_rate;
            }

            set
            {
                ((global::SharpSDL.DisplayMode.__Internal*)__Instance)->refresh_rate = value;
            }
        }

        public global::System.IntPtr Driverdata
        {
            get
            {
                return ((global::SharpSDL.DisplayMode.__Internal*) __Instance)->driverdata;
            }

            set
            {
                ((global::SharpSDL.DisplayMode.__Internal*)__Instance)->driverdata = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class SDL_video
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetNumVideoDrivers")]
            internal static extern int GetNumVideoDrivers();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetVideoDriver")]
            internal static extern global::System.IntPtr GetVideoDriver(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_VideoInit")]
            internal static extern int VideoInit([MarshalAs(UnmanagedType.LPStr)] string driver_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_VideoQuit")]
            internal static extern void VideoQuit();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetCurrentVideoDriver")]
            internal static extern global::System.IntPtr GetCurrentVideoDriver();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetNumVideoDisplays")]
            internal static extern int GetNumVideoDisplays();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDisplayName")]
            internal static extern global::System.IntPtr GetDisplayName(int displayIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDisplayBounds")]
            internal static extern int GetDisplayBounds(int displayIndex, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDisplayUsableBounds")]
            internal static extern int GetDisplayUsableBounds(int displayIndex, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDisplayDPI")]
            internal static extern int GetDisplayDPI(int displayIndex, float* ddpi, float* hdpi, float* vdpi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDisplayOrientation")]
            internal static extern global::SharpSDL.DisplayOrientation GetDisplayOrientation(int displayIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetNumDisplayModes")]
            internal static extern int GetNumDisplayModes(int displayIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDisplayMode")]
            internal static extern int GetDisplayMode(int displayIndex, int modeIndex, global::System.IntPtr mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDesktopDisplayMode")]
            internal static extern int GetDesktopDisplayMode(int displayIndex, global::System.IntPtr mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetCurrentDisplayMode")]
            internal static extern int GetCurrentDisplayMode(int displayIndex, global::System.IntPtr mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetClosestDisplayMode")]
            internal static extern global::System.IntPtr GetClosestDisplayMode(int displayIndex, global::System.IntPtr mode, global::System.IntPtr closest);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowDisplayIndex")]
            internal static extern int GetWindowDisplayIndex(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowDisplayMode")]
            internal static extern int SetWindowDisplayMode(global::System.IntPtr window, global::System.IntPtr mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowDisplayMode")]
            internal static extern int GetWindowDisplayMode(global::System.IntPtr window, global::System.IntPtr mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowPixelFormat")]
            internal static extern uint GetWindowPixelFormat(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateWindow")]
            internal static extern global::System.IntPtr CreateWindow([MarshalAs(UnmanagedType.LPStr)] string title, int x, int y, int w, int h, uint flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateWindowFrom")]
            internal static extern global::System.IntPtr CreateWindowFrom(global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowID")]
            internal static extern uint GetWindowID(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowFromID")]
            internal static extern global::System.IntPtr GetWindowFromID(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowFlags")]
            internal static extern uint GetWindowFlags(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowTitle")]
            internal static extern void SetWindowTitle(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowTitle")]
            internal static extern global::System.IntPtr GetWindowTitle(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowIcon")]
            internal static extern void SetWindowIcon(global::System.IntPtr window, global::System.IntPtr icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowData")]
            internal static extern global::System.IntPtr SetWindowData(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr userdata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowData")]
            internal static extern global::System.IntPtr GetWindowData(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowPosition")]
            internal static extern void SetWindowPosition(global::System.IntPtr window, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowPosition")]
            internal static extern void GetWindowPosition(global::System.IntPtr window, int* x, int* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowSize")]
            internal static extern void SetWindowSize(global::System.IntPtr window, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowSize")]
            internal static extern void GetWindowSize(global::System.IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowBordersSize")]
            internal static extern int GetWindowBordersSize(global::System.IntPtr window, int* top, int* left, int* bottom, int* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowMinimumSize")]
            internal static extern void SetWindowMinimumSize(global::System.IntPtr window, int min_w, int min_h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowMinimumSize")]
            internal static extern void GetWindowMinimumSize(global::System.IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowMaximumSize")]
            internal static extern void SetWindowMaximumSize(global::System.IntPtr window, int max_w, int max_h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowMaximumSize")]
            internal static extern void GetWindowMaximumSize(global::System.IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ShowWindow")]
            internal static extern void ShowWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_HideWindow")]
            internal static extern void HideWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RaiseWindow")]
            internal static extern void RaiseWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_MaximizeWindow")]
            internal static extern void MaximizeWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_MinimizeWindow")]
            internal static extern void MinimizeWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RestoreWindow")]
            internal static extern void RestoreWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowFullscreen")]
            internal static extern int SetWindowFullscreen(global::System.IntPtr window, uint flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowSurface")]
            internal static extern global::System.IntPtr GetWindowSurface(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UpdateWindowSurface")]
            internal static extern int UpdateWindowSurface(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UpdateWindowSurfaceRects")]
            internal static extern int UpdateWindowSurfaceRects(global::System.IntPtr window, global::System.IntPtr rects, int numrects);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetGrabbedWindow")]
            internal static extern global::System.IntPtr GetGrabbedWindow();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowBrightness")]
            internal static extern int SetWindowBrightness(global::System.IntPtr window, float brightness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowBrightness")]
            internal static extern float GetWindowBrightness(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowOpacity")]
            internal static extern int SetWindowOpacity(global::System.IntPtr window, float opacity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowOpacity")]
            internal static extern int GetWindowOpacity(global::System.IntPtr window, float* out_opacity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowModalFor")]
            internal static extern int SetWindowModalFor(global::System.IntPtr modal_window, global::System.IntPtr parent_window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowInputFocus")]
            internal static extern int SetWindowInputFocus(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowGammaRamp")]
            internal static extern int SetWindowGammaRamp(global::System.IntPtr window, ushort* red, ushort* green, ushort* blue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetWindowGammaRamp")]
            internal static extern int GetWindowGammaRamp(global::System.IntPtr window, ushort* red, ushort* green, ushort* blue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetWindowHitTest")]
            internal static extern int SetWindowHitTest(global::System.IntPtr window, global::System.IntPtr callback, global::System.IntPtr callback_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_DestroyWindow")]
            internal static extern void DestroyWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_EnableScreenSaver")]
            internal static extern void EnableScreenSaver();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_DisableScreenSaver")]
            internal static extern void DisableScreenSaver();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_LoadLibrary")]
            internal static extern int GL_LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_GetProcAddress")]
            internal static extern global::System.IntPtr GL_GetProcAddress([MarshalAs(UnmanagedType.LPStr)] string proc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_UnloadLibrary")]
            internal static extern void GL_UnloadLibrary();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_ResetAttributes")]
            internal static extern void GL_ResetAttributes();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_SetAttribute")]
            internal static extern int GL_SetAttribute(global::SharpSDL.GLattr attr, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_GetAttribute")]
            internal static extern int GL_GetAttribute(global::SharpSDL.GLattr attr, int* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_CreateContext")]
            internal static extern global::System.IntPtr GL_CreateContext(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_MakeCurrent")]
            internal static extern int GL_MakeCurrent(global::System.IntPtr window, global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_GetCurrentWindow")]
            internal static extern global::System.IntPtr GL_GetCurrentWindow();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_GetCurrentContext")]
            internal static extern global::System.IntPtr GL_GetCurrentContext();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_GetDrawableSize")]
            internal static extern void GL_GetDrawableSize(global::System.IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_SetSwapInterval")]
            internal static extern int GL_SetSwapInterval(int interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_GetSwapInterval")]
            internal static extern int GL_GetSwapInterval();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_SwapWindow")]
            internal static extern void GL_SwapWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_DeleteContext")]
            internal static extern void GL_DeleteContext(global::System.IntPtr context);
        }

        /// <summary>Get the number of video drivers compiled into SDL</summary>
/// <remarks>SDL_GetVideoDriver()</remarks>
        public static int GetNumVideoDrivers()
        {
            var __ret = __Internal.GetNumVideoDrivers();
            return __ret;
        }

        /// <summary>Get the name of a built in video driver.</summary>
/// <remarks>
/// <para>The video drivers are presented in the order in which they are</para>
/// <para>normally checked during initialization.</para>
/// <para>SDL_GetNumVideoDrivers()</para>
/// </remarks>
        public static string GetVideoDriver(int index)
        {
            var __ret = __Internal.GetVideoDriver(index);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Initialize the video subsystem, optionally specifying a video driver.</summary>
/// <param name="driver_name">
/// <para>Initialize a specific driver by name, or NULL for the</para>
/// <para>default video driver.</para>
/// </param>
/// <returns>
/// <para>0 on success, -1 on error</para>
/// <para>This function initializes the video subsystem; setting up a connection</para>
/// <para>to the window manager, etc, and determines the available display modes</para>
/// <para>and pixel formats, but does not initialize a window or graphics mode.</para>
/// </returns>
/// <remarks>SDL_VideoQuit()</remarks>
        public static int VideoInit(string driver_name)
        {
            var __ret = __Internal.VideoInit(driver_name);
            return __ret;
        }

        /// <summary>Shuts down the video subsystem.</summary>
/// <remarks>
/// <para>This function closes all windows, and restores the original video mode.</para>
/// <para>SDL_VideoInit()</para>
/// </remarks>
        public static void VideoQuit()
        {
            __Internal.VideoQuit();
        }

        /// <summary>Returns the name of the currently initialized video driver.</summary>
/// <returns>
/// <para>The name of the current video driver or NULL if no driver</para>
/// <para>has been initialized</para>
/// </returns>
/// <remarks>
/// <para>SDL_GetNumVideoDrivers()</para>
/// <para>SDL_GetVideoDriver()</para>
/// </remarks>
        public static string GetCurrentVideoDriver()
        {
            var __ret = __Internal.GetCurrentVideoDriver();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Returns the number of available video displays.</summary>
/// <remarks>SDL_GetDisplayBounds()</remarks>
        public static int GetNumVideoDisplays()
        {
            var __ret = __Internal.GetNumVideoDisplays();
            return __ret;
        }

        /// <summary>Get the name of a display in UTF-8 encoding</summary>
/// <returns>The name of a display, or NULL for an invalid display index.</returns>
/// <remarks>SDL_GetNumVideoDisplays()</remarks>
        public static string GetDisplayName(int displayIndex)
        {
            var __ret = __Internal.GetDisplayName(displayIndex);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
/// <para>Get the desktop area represented by a display, with the primary</para>
/// <para>display located at 0,0</para>
/// </summary>
/// <returns>0 on success, or -1 if the index is out of range.</returns>
/// <remarks>SDL_GetNumVideoDisplays()</remarks>
        public static int GetDisplayBounds(int displayIndex, global::SharpSDL.Rect rect)
        {
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.GetDisplayBounds(displayIndex, __arg1);
            return __ret;
        }

        /// <summary>
/// <para>Get the usable desktop area represented by a display, with the</para>
/// <para>primary display located at 0,0</para>
/// </summary>
/// <returns>0 on success, or -1 if the index is out of range.</returns>
/// <remarks>
/// <para>This is the same area as SDL_GetDisplayBounds() reports, but with portions</para>
/// <para>reserved by the system removed. For example, on Mac OS X, this subtracts</para>
/// <para>the area occupied by the menu bar and dock.</para>
/// <para>Setting a window to be fullscreen generally bypasses these unusable areas,</para>
/// <para>so these are good guidelines for the maximum space available to a</para>
/// <para>non-fullscreen window.</para>
/// <para>SDL_GetDisplayBounds()</para>
/// <para>SDL_GetNumVideoDisplays()</para>
/// </remarks>
        public static int GetDisplayUsableBounds(int displayIndex, global::SharpSDL.Rect rect)
        {
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.GetDisplayUsableBounds(displayIndex, __arg1);
            return __ret;
        }

        /// <summary>Get the dots/pixels-per-inch for a display</summary>
/// <returns>0 on success, or -1 if no DPI information is available or the index is out of range.</returns>
/// <remarks>
/// <para>Diagonal, horizontal and vertical DPI can all be optionally</para>
/// <para>returned if the parameter is non-NULL.</para>
/// <para>SDL_GetNumVideoDisplays()</para>
/// </remarks>
        public static int GetDisplayDPI(int displayIndex, ref float ddpi, ref float hdpi, ref float vdpi)
        {
            fixed (float* __ddpi1 = &ddpi)
            {
                var __arg1 = __ddpi1;
                fixed (float* __hdpi2 = &hdpi)
                {
                    var __arg2 = __hdpi2;
                    fixed (float* __vdpi3 = &vdpi)
                    {
                        var __arg3 = __vdpi3;
                        var __ret = __Internal.GetDisplayDPI(displayIndex, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        /// <summary>Get the orientation of a display</summary>
/// <returns>The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available.</returns>
/// <remarks>SDL_GetNumVideoDisplays()</remarks>
        public static global::SharpSDL.DisplayOrientation GetDisplayOrientation(int displayIndex)
        {
            var __ret = __Internal.GetDisplayOrientation(displayIndex);
            return __ret;
        }

        /// <summary>Returns the number of available display modes.</summary>
/// <remarks>SDL_GetDisplayMode()</remarks>
        public static int GetNumDisplayModes(int displayIndex)
        {
            var __ret = __Internal.GetNumDisplayModes(displayIndex);
            return __ret;
        }

        /// <summary>Fill in information about a specific display mode.</summary>
/// <remarks>
/// <para>The display modes are sorted in this priority:</para>
/// <para>bits per pixel -&gt; more colors to fewer colors</para>
/// <para>width -&gt; largest to smallest</para>
/// <para>height -&gt; largest to smallest</para>
/// <para>refresh rate -&gt; highest to lowest</para>
/// <para>SDL_GetNumDisplayModes()</para>
/// </remarks>
        public static int GetDisplayMode(int displayIndex, int modeIndex, global::SharpSDL.DisplayMode mode)
        {
            var __arg2 = ReferenceEquals(mode, null) ? global::System.IntPtr.Zero : mode.__Instance;
            var __ret = __Internal.GetDisplayMode(displayIndex, modeIndex, __arg2);
            return __ret;
        }

        /// <summary>Fill in information about the desktop display mode.</summary>
        public static int GetDesktopDisplayMode(int displayIndex, global::SharpSDL.DisplayMode mode)
        {
            var __arg1 = ReferenceEquals(mode, null) ? global::System.IntPtr.Zero : mode.__Instance;
            var __ret = __Internal.GetDesktopDisplayMode(displayIndex, __arg1);
            return __ret;
        }

        /// <summary>Fill in information about the current display mode.</summary>
        public static int GetCurrentDisplayMode(int displayIndex, global::SharpSDL.DisplayMode mode)
        {
            var __arg1 = ReferenceEquals(mode, null) ? global::System.IntPtr.Zero : mode.__Instance;
            var __ret = __Internal.GetCurrentDisplayMode(displayIndex, __arg1);
            return __ret;
        }

        /// <summary>Get the closest match to the requested display mode.</summary>
/// <param name="displayIndex">The index of display from which mode should be queried.</param>
/// <param name="mode">The desired display mode</param>
/// <param name="closest">
/// <para>A pointer to a display mode to be filled in with the closest</para>
/// <para>match of the available display modes.</para>
/// </param>
/// <returns>
/// <para>The passed in valueor NULL if no matching video mode</para>
/// <para>was available.</para>
/// <para>The available display modes are scanned, andis filled in with the</para>
/// <para>closest mode matching the requested mode and returned.  The mode format and</para>
/// <para>refresh_rate default to the desktop mode if they are 0.  The modes are</para>
/// <para>scanned with size being first priority, format being second priority, and</para>
/// <para>finally checking the refresh_rate.  If all the available modes are too</para>
/// <para>small, then NULL is returned.</para>
/// </returns>
/// <remarks>
/// <para>SDL_GetNumDisplayModes()</para>
/// <para>SDL_GetDisplayMode()</para>
/// </remarks>
        public static global::SharpSDL.DisplayMode GetClosestDisplayMode(int displayIndex, global::SharpSDL.DisplayMode mode, global::SharpSDL.DisplayMode closest)
        {
            var __arg1 = ReferenceEquals(mode, null) ? global::System.IntPtr.Zero : mode.__Instance;
            var __arg2 = ReferenceEquals(closest, null) ? global::System.IntPtr.Zero : closest.__Instance;
            var __ret = __Internal.GetClosestDisplayMode(displayIndex, __arg1, __arg2);
            global::SharpSDL.DisplayMode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.DisplayMode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.DisplayMode) global::SharpSDL.DisplayMode.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.DisplayMode.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the display index associated with a window.</summary>
/// <returns>
/// <para>the display index of the display containing the center of the</para>
/// <para>window, or -1 on error.</para>
/// </returns>
        public static int GetWindowDisplayIndex(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowDisplayIndex(__arg0);
            return __ret;
        }

        /// <summary>Set the display mode used when a fullscreen window is visible.</summary>
/// <param name="window">The window for which the display mode should be set.</param>
/// <param name="mode">The mode to use, or NULL for the default mode.</param>
/// <returns>0 on success, or -1 if setting the display mode failed.</returns>
/// <remarks>
/// <para>By default the window's dimensions and the desktop format and refresh rate</para>
/// <para>are used.</para>
/// <para>SDL_GetWindowDisplayMode()</para>
/// <para>SDL_SetWindowFullscreen()</para>
/// </remarks>
        public static int SetWindowDisplayMode(global::SharpSDL.Window window, global::SharpSDL.DisplayMode mode)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(mode, null) ? global::System.IntPtr.Zero : mode.__Instance;
            var __ret = __Internal.SetWindowDisplayMode(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
/// <para>Fill in information about the display mode used when a fullscreen</para>
/// <para>window is visible.</para>
/// </summary>
/// <remarks>
/// <para>SDL_SetWindowDisplayMode()</para>
/// <para>SDL_SetWindowFullscreen()</para>
/// </remarks>
        public static int GetWindowDisplayMode(global::SharpSDL.Window window, global::SharpSDL.DisplayMode mode)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(mode, null) ? global::System.IntPtr.Zero : mode.__Instance;
            var __ret = __Internal.GetWindowDisplayMode(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get the pixel format associated with the window.</summary>
        public static uint GetWindowPixelFormat(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowPixelFormat(__arg0);
            return __ret;
        }

        /// <summary>Create a window with the specified position, dimensions, and flags.</summary>
/// <param name="title">The title of the window, in UTF-8 encoding.</param>
/// <param name="x">
/// <para>The x position of the window, ::SDL_WINDOWPOS_CENTERED, or</para>
/// <para>::SDL_WINDOWPOS_UNDEFINED.</para>
/// </param>
/// <param name="y">
/// <para>The y position of the window, ::SDL_WINDOWPOS_CENTERED, or</para>
/// <para>::SDL_WINDOWPOS_UNDEFINED.</para>
/// </param>
/// <param name="w">The width of the window, in screen coordinates.</param>
/// <param name="h">The height of the window, in screen coordinates.</param>
/// <param name="flags">
/// <para>The flags for the window, a mask of any of the following:</para>
/// <para>::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,</para>
/// <para>::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,</para>
/// <para>::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,</para>
/// <para>::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,</para>
/// <para>::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN.</para>
/// </param>
/// <returns>
/// <para>The created window, or NULL if window creation failed.</para>
/// <para>If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size</para>
/// <para>in pixels may differ from its size in screen coordinates on platforms with</para>
/// <para>high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query</para>
/// <para>the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),</para>
/// <para>SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the</para>
/// <para>drawable size in pixels.</para>
/// <para>If the window is created with any of the SDL_WINDOW_OPENGL or</para>
/// <para>SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function</para>
/// <para>(SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the</para>
/// <para>corresponding UnloadLibrary function is called by SDL_DestroyWindow().</para>
/// <para>If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,</para>
/// <para>SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.</para>
/// </returns>
/// <remarks>
/// <para>On non-Apple devices, SDL requires you to either not link to the</para>
/// <para>Vulkan loader or link to a dynamic library version. This limitation</para>
/// <para>may be removed in a future version of SDL.</para>
/// <para>SDL_DestroyWindow()</para>
/// <para>SDL_GL_LoadLibrary()</para>
/// <para>SDL_Vulkan_LoadLibrary()</para>
/// </remarks>
        public static global::SharpSDL.Window CreateWindow(string title, int x, int y, int w, int h, uint flags)
        {
            var __ret = __Internal.CreateWindow(title, x, y, w, h, flags);
            global::SharpSDL.Window __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Window.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Window) global::SharpSDL.Window.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Window.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create an SDL window from an existing native window.</summary>
/// <param name="data">A pointer to driver-dependent window creation data</param>
/// <returns>The created window, or NULL if window creation failed.</returns>
/// <remarks>SDL_DestroyWindow()</remarks>
        public static global::SharpSDL.Window CreateWindowFrom(global::System.IntPtr data)
        {
            var __ret = __Internal.CreateWindowFrom(data);
            global::SharpSDL.Window __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Window.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Window) global::SharpSDL.Window.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Window.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the numeric ID of a window, for logging purposes.</summary>
        public static uint GetWindowID(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowID(__arg0);
            return __ret;
        }

        /// <summary>Get a window from a stored ID, or NULL if it doesn't exist.</summary>
        public static global::SharpSDL.Window GetWindowFromID(uint id)
        {
            var __ret = __Internal.GetWindowFromID(id);
            global::SharpSDL.Window __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Window.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Window) global::SharpSDL.Window.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Window.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the window flags.</summary>
        public static uint GetWindowFlags(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowFlags(__arg0);
            return __ret;
        }

        /// <summary>Set the title of a window, in UTF-8 format.</summary>
/// <remarks>SDL_GetWindowTitle()</remarks>
        public static void SetWindowTitle(global::SharpSDL.Window window, string title)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowTitle(__arg0, title);
        }

        /// <summary>Get the title of a window, in UTF-8 format.</summary>
/// <remarks>SDL_SetWindowTitle()</remarks>
        public static string GetWindowTitle(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowTitle(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Set the icon for a window.</summary>
/// <param name="window">The window for which the icon should be set.</param>
/// <param name="icon">The icon for the window.</param>
        public static void SetWindowIcon(global::SharpSDL.Window window, global::SharpSDL.Surface icon)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(icon, null) ? global::System.IntPtr.Zero : icon.__Instance;
            __Internal.SetWindowIcon(__arg0, __arg1);
        }

        /// <summary>Associate an arbitrary named pointer with a window.</summary>
/// <param name="window">The window to associate with the pointer.</param>
/// <param name="name">The name of the pointer.</param>
/// <param name="userdata">The associated pointer.</param>
/// <returns>The previous value associated with 'name'</returns>
/// <remarks>
/// <para>The name is case-sensitive.</para>
/// <para>SDL_GetWindowData()</para>
/// </remarks>
        public static global::System.IntPtr SetWindowData(global::SharpSDL.Window window, string name, global::System.IntPtr userdata)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.SetWindowData(__arg0, name, userdata);
            return __ret;
        }

        /// <summary>Retrieve the data pointer associated with a window.</summary>
/// <param name="window">The window to query.</param>
/// <param name="name">The name of the pointer.</param>
/// <returns>The value associated with 'name'</returns>
/// <remarks>SDL_SetWindowData()</remarks>
        public static global::System.IntPtr GetWindowData(global::SharpSDL.Window window, string name)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowData(__arg0, name);
            return __ret;
        }

        /// <summary>Set the position of a window.</summary>
/// <param name="window">The window to reposition.</param>
/// <param name="x">
/// <para>The x coordinate of the window in screen coordinates, or</para>
/// <para>::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.</para>
/// </param>
/// <param name="y">
/// <para>The y coordinate of the window in screen coordinates, or</para>
/// <para>::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.</para>
/// </param>
/// <remarks>
/// <para>The window coordinate origin is the upper left of the display.</para>
/// <para>SDL_GetWindowPosition()</para>
/// </remarks>
        public static void SetWindowPosition(global::SharpSDL.Window window, int x, int y)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowPosition(__arg0, x, y);
        }

        /// <summary>Get the position of a window.</summary>
/// <param name="window">The window to query.</param>
/// <param name="x">
/// <para>Pointer to variable for storing the x position, in screen</para>
/// <para>coordinates. May be NULL.</para>
/// </param>
/// <param name="y">
/// <para>Pointer to variable for storing the y position, in screen</para>
/// <para>coordinates. May be NULL.</para>
/// </param>
/// <remarks>SDL_SetWindowPosition()</remarks>
        public static void GetWindowPosition(global::SharpSDL.Window window, ref int x, ref int y)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __x1 = &x)
            {
                var __arg1 = __x1;
                fixed (int* __y2 = &y)
                {
                    var __arg2 = __y2;
                    __Internal.GetWindowPosition(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Set the size of a window's client area.</summary>
/// <param name="window">The window to resize.</param>
/// <param name="w">The width of the window, in screen coordinates. Must be &gt;0.</param>
/// <param name="h">The height of the window, in screen coordinates. Must be &gt;0.</param>
/// <remarks>
/// <para>Fullscreen windows automatically match the size of the display mode,</para>
/// <para>and you should use SDL_SetWindowDisplayMode() to change their size.</para>
/// <para>The window size in screen coordinates may differ from the size in pixels, if</para>
/// <para>the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with</para>
/// <para>high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or</para>
/// <para>SDL_GetRendererOutputSize() to get the real client area size in pixels.</para>
/// <para>SDL_GetWindowSize()</para>
/// <para>SDL_SetWindowDisplayMode()</para>
/// </remarks>
        public static void SetWindowSize(global::SharpSDL.Window window, int w, int h)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowSize(__arg0, w, h);
        }

        /// <summary>Get the size of a window's client area.</summary>
/// <param name="window">The window to query.</param>
/// <param name="w">
/// <para>Pointer to variable for storing the width, in screen</para>
/// <para>coordinates. May be NULL.</para>
/// </param>
/// <param name="h">
/// <para>Pointer to variable for storing the height, in screen</para>
/// <para>coordinates. May be NULL.</para>
/// </param>
/// <remarks>
/// <para>The window size in screen coordinates may differ from the size in pixels, if</para>
/// <para>the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with</para>
/// <para>high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or</para>
/// <para>SDL_GetRendererOutputSize() to get the real client area size in pixels.</para>
/// <para>SDL_SetWindowSize()</para>
/// </remarks>
        public static void GetWindowSize(global::SharpSDL.Window window, ref int w, ref int h)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    __Internal.GetWindowSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Get the size of a window's borders (decorations) around the client area.</summary>
/// <param name="window">The window to query.</param>
/// <param name="top">Pointer to variable for storing the size of the top border. NULL is permitted.</param>
/// <param name="left">Pointer to variable for storing the size of the left border. NULL is permitted.</param>
/// <param name="bottom">Pointer to variable for storing the size of the bottom border. NULL is permitted.</param>
/// <param name="right">Pointer to variable for storing the size of the right border. NULL is permitted.</param>
/// <returns>0 on success, or -1 if getting this information is not supported.</returns>
/// <remarks>
/// <para>if this function fails (returns -1), the size values will be</para>
/// <para>initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as</para>
/// <para>if the window in question was borderless.</para>
/// </remarks>
        public static int GetWindowBordersSize(global::SharpSDL.Window window, ref int top, ref int left, ref int bottom, ref int right)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __top1 = &top)
            {
                var __arg1 = __top1;
                fixed (int* __left2 = &left)
                {
                    var __arg2 = __left2;
                    fixed (int* __bottom3 = &bottom)
                    {
                        var __arg3 = __bottom3;
                        fixed (int* __right4 = &right)
                        {
                            var __arg4 = __right4;
                            var __ret = __Internal.GetWindowBordersSize(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>Set the minimum size of a window's client area.</summary>
/// <param name="window">The window to set a new minimum size.</param>
/// <param name="min_w">The minimum width of the window, must be &gt;0</param>
/// <param name="min_h">The minimum height of the window, must be &gt;0</param>
/// <remarks>
/// <para>You can't change the minimum size of a fullscreen window, it</para>
/// <para>automatically matches the size of the display mode.</para>
/// <para>SDL_GetWindowMinimumSize()</para>
/// <para>SDL_SetWindowMaximumSize()</para>
/// </remarks>
        public static void SetWindowMinimumSize(global::SharpSDL.Window window, int min_w, int min_h)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowMinimumSize(__arg0, min_w, min_h);
        }

        /// <summary>Get the minimum size of a window's client area.</summary>
/// <param name="window">The window to query.</param>
/// <param name="w">Pointer to variable for storing the minimum width, may be NULL</param>
/// <param name="h">Pointer to variable for storing the minimum height, may be NULL</param>
/// <remarks>
/// <para>SDL_GetWindowMaximumSize()</para>
/// <para>SDL_SetWindowMinimumSize()</para>
/// </remarks>
        public static void GetWindowMinimumSize(global::SharpSDL.Window window, ref int w, ref int h)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    __Internal.GetWindowMinimumSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Set the maximum size of a window's client area.</summary>
/// <param name="window">The window to set a new maximum size.</param>
/// <param name="max_w">The maximum width of the window, must be &gt;0</param>
/// <param name="max_h">The maximum height of the window, must be &gt;0</param>
/// <remarks>
/// <para>You can't change the maximum size of a fullscreen window, it</para>
/// <para>automatically matches the size of the display mode.</para>
/// <para>SDL_GetWindowMaximumSize()</para>
/// <para>SDL_SetWindowMinimumSize()</para>
/// </remarks>
        public static void SetWindowMaximumSize(global::SharpSDL.Window window, int max_w, int max_h)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowMaximumSize(__arg0, max_w, max_h);
        }

        /// <summary>Get the maximum size of a window's client area.</summary>
/// <param name="window">The window to query.</param>
/// <param name="w">Pointer to variable for storing the maximum width, may be NULL</param>
/// <param name="h">Pointer to variable for storing the maximum height, may be NULL</param>
/// <remarks>
/// <para>SDL_GetWindowMinimumSize()</para>
/// <para>SDL_SetWindowMaximumSize()</para>
/// </remarks>
        public static void GetWindowMaximumSize(global::SharpSDL.Window window, ref int w, ref int h)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    __Internal.GetWindowMaximumSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Show a window.</summary>
/// <remarks>SDL_HideWindow()</remarks>
        public static void ShowWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.ShowWindow(__arg0);
        }

        /// <summary>Hide a window.</summary>
/// <remarks>SDL_ShowWindow()</remarks>
        public static void HideWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.HideWindow(__arg0);
        }

        /// <summary>Raise a window above other windows and set the input focus.</summary>
        public static void RaiseWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.RaiseWindow(__arg0);
        }

        /// <summary>Make a window as large as possible.</summary>
/// <remarks>SDL_RestoreWindow()</remarks>
        public static void MaximizeWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.MaximizeWindow(__arg0);
        }

        /// <summary>Minimize a window to an iconic representation.</summary>
/// <remarks>SDL_RestoreWindow()</remarks>
        public static void MinimizeWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.MinimizeWindow(__arg0);
        }

        /// <summary>Restore the size and position of a minimized or maximized window.</summary>
/// <remarks>
/// <para>SDL_MaximizeWindow()</para>
/// <para>SDL_MinimizeWindow()</para>
/// </remarks>
        public static void RestoreWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.RestoreWindow(__arg0);
        }

        /// <summary>Set a window's fullscreen state.</summary>
/// <returns>0 on success, or -1 if setting the display mode failed.</returns>
/// <remarks>
/// <para>SDL_SetWindowDisplayMode()</para>
/// <para>SDL_GetWindowDisplayMode()</para>
/// </remarks>
        public static int SetWindowFullscreen(global::SharpSDL.Window window, uint flags)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.SetWindowFullscreen(__arg0, flags);
            return __ret;
        }

        /// <summary>Get the SDL surface associated with the window.</summary>
/// <returns>
/// <para>The window's framebuffer surface, or NULL on error.</para>
/// <para>A new surface will be created with the optimal format for the window,</para>
/// <para>if necessary. This surface will be freed when the window is destroyed.</para>
/// </returns>
/// <remarks>
/// <para>You may not combine this with 3D or the rendering API on this window.</para>
/// <para>SDL_UpdateWindowSurface()</para>
/// <para>SDL_UpdateWindowSurfaceRects()</para>
/// </remarks>
        public static global::SharpSDL.Surface GetWindowSurface(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowSurface(__arg0);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Copy the window surface to the screen.</summary>
/// <returns>0 on success, or -1 on error.</returns>
/// <remarks>
/// <para>SDL_GetWindowSurface()</para>
/// <para>SDL_UpdateWindowSurfaceRects()</para>
/// </remarks>
        public static int UpdateWindowSurface(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.UpdateWindowSurface(__arg0);
            return __ret;
        }

        /// <summary>Copy a number of rectangles on the window surface to the screen.</summary>
/// <returns>0 on success, or -1 on error.</returns>
/// <remarks>
/// <para>SDL_GetWindowSurface()</para>
/// <para>SDL_UpdateWindowSurface()</para>
/// </remarks>
        public static int UpdateWindowSurfaceRects(global::SharpSDL.Window window, global::SharpSDL.Rect rects, int numrects)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(rects, null) ? global::System.IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.UpdateWindowSurfaceRects(__arg0, __arg1, numrects);
            return __ret;
        }

        /// <summary>Get the window that currently has an input grab enabled.</summary>
/// <returns>This returns the window if input is grabbed, and NULL otherwise.</returns>
/// <remarks>SDL_SetWindowGrab()</remarks>
        public static global::SharpSDL.Window GetGrabbedWindow()
        {
            var __ret = __Internal.GetGrabbedWindow();
            global::SharpSDL.Window __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Window.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Window) global::SharpSDL.Window.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Window.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set the brightness (gamma correction) for a window.</summary>
/// <returns>0 on success, or -1 if setting the brightness isn't supported.</returns>
/// <remarks>
/// <para>SDL_GetWindowBrightness()</para>
/// <para>SDL_SetWindowGammaRamp()</para>
/// </remarks>
        public static int SetWindowBrightness(global::SharpSDL.Window window, float brightness)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.SetWindowBrightness(__arg0, brightness);
            return __ret;
        }

        /// <summary>Get the brightness (gamma correction) for a window.</summary>
/// <returns>The last brightness value passed to SDL_SetWindowBrightness()</returns>
/// <remarks>SDL_SetWindowBrightness()</remarks>
        public static float GetWindowBrightness(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowBrightness(__arg0);
            return __ret;
        }

        /// <summary>Set the opacity for a window</summary>
/// <param name="window">The window which will be made transparent or opaque</param>
/// <param name="opacity">
/// <para>Opacity (0.0f - transparent, 1.0f - opaque) This will be</para>
/// <para>clamped internally between 0.0f and 1.0f.</para>
/// </param>
/// <returns>0 on success, or -1 if setting the opacity isn't supported.</returns>
/// <remarks>SDL_GetWindowOpacity()</remarks>
        public static int SetWindowOpacity(global::SharpSDL.Window window, float opacity)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.SetWindowOpacity(__arg0, opacity);
            return __ret;
        }

        /// <summary>Get the opacity of a window.</summary>
/// <param name="window">The window in question.</param>
/// <param name="out_opacity">Opacity (0.0f - transparent, 1.0f - opaque)</param>
/// <returns>0 on success, or -1 on error (invalid window, etc).</returns>
/// <remarks>
/// <para>If transparency isn't supported on this platform, opacity will be reported</para>
/// <para>as 1.0f without error.</para>
/// <para>SDL_SetWindowOpacity()</para>
/// </remarks>
        public static int GetWindowOpacity(global::SharpSDL.Window window, ref float out_opacity)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (float* __out_opacity1 = &out_opacity)
            {
                var __arg1 = __out_opacity1;
                var __ret = __Internal.GetWindowOpacity(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Sets the window as a modal for another window (TODO: reconsider this function and/or its name)</summary>
/// <param name="modal_window">The window that should be modal</param>
/// <param name="parent_window">The parent window</param>
/// <returns>0 on success, or -1 otherwise.</returns>
        public static int SetWindowModalFor(global::SharpSDL.Window modal_window, global::SharpSDL.Window parent_window)
        {
            var __arg0 = ReferenceEquals(modal_window, null) ? global::System.IntPtr.Zero : modal_window.__Instance;
            var __arg1 = ReferenceEquals(parent_window, null) ? global::System.IntPtr.Zero : parent_window.__Instance;
            var __ret = __Internal.SetWindowModalFor(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Explicitly sets input focus to the window.</summary>
/// <param name="window">The window that should get the input focus</param>
/// <returns>0 on success, or -1 otherwise.</returns>
/// <remarks>
/// <para>You almost certainly want SDL_RaiseWindow() instead of this function. Use</para>
/// <para>this with caution, as you might give focus to a window that's completely</para>
/// <para>obscured by other windows.</para>
/// <para>SDL_RaiseWindow()</para>
/// </remarks>
        public static int SetWindowInputFocus(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.SetWindowInputFocus(__arg0);
            return __ret;
        }

        /// <summary>Set the gamma ramp for a window.</summary>
/// <param name="window">The window for which the gamma ramp should be set.</param>
/// <param name="red">The translation table for the red channel, or NULL.</param>
/// <param name="green">The translation table for the green channel, or NULL.</param>
/// <param name="blue">The translation table for the blue channel, or NULL.</param>
/// <returns>
/// <para>0 on success, or -1 if gamma ramps are unsupported.</para>
/// <para>Set the gamma translation table for the red, green, and blue channels</para>
/// <para>of the video hardware.  Each table is an array of 256 16-bit quantities,</para>
/// <para>representing a mapping between the input and output for that channel.</para>
/// <para>The input is the index into the array, and the output is the 16-bit</para>
/// <para>gamma value at that index, scaled to the output color precision.</para>
/// </returns>
/// <remarks>SDL_GetWindowGammaRamp()</remarks>
        public static int SetWindowGammaRamp(global::SharpSDL.Window window, ref ushort red, ref ushort green, ref ushort blue)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (ushort* __red1 = &red)
            {
                var __arg1 = __red1;
                fixed (ushort* __green2 = &green)
                {
                    var __arg2 = __green2;
                    fixed (ushort* __blue3 = &blue)
                    {
                        var __arg3 = __blue3;
                        var __ret = __Internal.SetWindowGammaRamp(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        /// <summary>Get the gamma ramp for a window.</summary>
/// <param name="window">The window from which the gamma ramp should be queried.</param>
/// <param name="red">
/// <para>A pointer to a 256 element array of 16-bit quantities to hold</para>
/// <para>the translation table for the red channel, or NULL.</para>
/// </param>
/// <param name="green">
/// <para>A pointer to a 256 element array of 16-bit quantities to hold</para>
/// <para>the translation table for the green channel, or NULL.</para>
/// </param>
/// <param name="blue">
/// <para>A pointer to a 256 element array of 16-bit quantities to hold</para>
/// <para>the translation table for the blue channel, or NULL.</para>
/// </param>
/// <returns>0 on success, or -1 if gamma ramps are unsupported.</returns>
/// <remarks>SDL_SetWindowGammaRamp()</remarks>
        public static int GetWindowGammaRamp(global::SharpSDL.Window window, ref ushort red, ref ushort green, ref ushort blue)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (ushort* __red1 = &red)
            {
                var __arg1 = __red1;
                fixed (ushort* __green2 = &green)
                {
                    var __arg2 = __green2;
                    fixed (ushort* __blue3 = &blue)
                    {
                        var __arg3 = __blue3;
                        var __ret = __Internal.GetWindowGammaRamp(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        /// <summary>Provide a callback that decides if a window region has special properties.</summary>
/// <param name="window">The window to set hit-testing on.</param>
/// <param name="callback">The callback to call when doing a hit-test.</param>
/// <param name="callback_data">An app-defined void pointer passed to the callback.</param>
/// <returns>0 on success, -1 on error (including unsupported).</returns>
/// <remarks>
/// <para>Normally windows are dragged and resized by decorations provided by the</para>
/// <para>system window manager (a title bar, borders, etc), but for some apps, it</para>
/// <para>makes sense to drag them from somewhere else inside the window itself; for</para>
/// <para>example, one might have a borderless window that wants to be draggable</para>
/// <para>from any part, or simulate its own title bar, etc.</para>
/// <para>This function lets the app provide a callback that designates pieces of</para>
/// <para>a given window as special. This callback is run during event processing</para>
/// <para>if we need to tell the OS to treat a region of the window specially; the</para>
/// <para>use of this callback is known as &quot;hit testing.&quot;</para>
/// <para>Mouse input may not be delivered to your application if it is within</para>
/// <para>a special area; the OS will often apply that input to moving the window or</para>
/// <para>resizing the window and not deliver it to the application.</para>
/// <para>Specifying NULL for a callback disables hit-testing. Hit-testing is</para>
/// <para>disabled by default.</para>
/// <para>Platforms that don't support this functionality will return -1</para>
/// <para>unconditionally, even if you're attempting to disable hit-testing.</para>
/// <para>Your callback may fire at any time, and its firing does not indicate any</para>
/// <para>specific behavior (for example, on Windows, this certainly might fire</para>
/// <para>when the OS is deciding whether to drag your window, but it fires for lots</para>
/// <para>of other reasons, too, some unrelated to anything you probably care about</para>
/// <para>_and when the mouse isn't actually at the location it is testing_).</para>
/// <para>Since this can fire at any time, you should try to keep your callback</para>
/// <para>efficient, devoid of allocations, etc.</para>
/// </remarks>
        public static int SetWindowHitTest(global::SharpSDL.Window window, global::SharpSDL.HitTest callback, global::System.IntPtr callback_data)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.SetWindowHitTest(__arg0, __arg1, callback_data);
            return __ret;
        }

        /// <summary>Destroy a window.</summary>
        public static void DestroyWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.DestroyWindow(__arg0);
        }

        /// <summary>Allow the screen to be blanked by a screensaver</summary>
/// <remarks>
/// <para>SDL_IsScreenSaverEnabled()</para>
/// <para>SDL_DisableScreenSaver()</para>
/// </remarks>
        public static void EnableScreenSaver()
        {
            __Internal.EnableScreenSaver();
        }

        /// <summary>Prevent the screen from being blanked by a screensaver</summary>
/// <remarks>
/// <para>SDL_IsScreenSaverEnabled()</para>
/// <para>SDL_EnableScreenSaver()</para>
/// </remarks>
        public static void DisableScreenSaver()
        {
            __Internal.DisableScreenSaver();
        }

        /// <summary>Dynamically load an OpenGL library.</summary>
/// <param name="path">
/// <para>The platform dependent OpenGL library name, or NULL to open the</para>
/// <para>default OpenGL library.</para>
/// </param>
/// <returns>
/// <para>0 on success, or -1 if the library couldn't be loaded.</para>
/// <para>This should be done after initializing the video driver, but before</para>
/// <para>creating any OpenGL windows.  If no OpenGL library is loaded, the default</para>
/// <para>library will be loaded upon creation of the first OpenGL window.</para>
/// </returns>
/// <remarks>
/// <para>If you do this, you need to retrieve all of the GL functions used in</para>
/// <para>your program from the dynamic library using SDL_GL_GetProcAddress().</para>
/// <para>SDL_GL_GetProcAddress()</para>
/// <para>SDL_GL_UnloadLibrary()</para>
/// </remarks>
        public static int GL_LoadLibrary(string path)
        {
            var __ret = __Internal.GL_LoadLibrary(path);
            return __ret;
        }

        /// <summary>Get the address of an OpenGL function.</summary>
        public static global::System.IntPtr GL_GetProcAddress(string proc)
        {
            var __ret = __Internal.GL_GetProcAddress(proc);
            return __ret;
        }

        /// <summary>Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().</summary>
/// <remarks>SDL_GL_LoadLibrary()</remarks>
        public static void GL_UnloadLibrary()
        {
            __Internal.GL_UnloadLibrary();
        }

        /// <summary>Reset all previously set OpenGL context attributes to their default values</summary>
        public static void GL_ResetAttributes()
        {
            __Internal.GL_ResetAttributes();
        }

        /// <summary>Set an OpenGL window attribute before window creation.</summary>
/// <returns>0 on success, or -1 if the attribute could not be set.</returns>
        public static int GL_SetAttribute(global::SharpSDL.GLattr attr, int value)
        {
            var __ret = __Internal.GL_SetAttribute(attr, value);
            return __ret;
        }

        /// <summary>Get the actual value for an attribute from the current context.</summary>
/// <returns>
/// <para>0 on success, or -1 if the attribute could not be retrieved.</para>
/// <para>The integer atwill be modified in either case.</para>
/// </returns>
        public static int GL_GetAttribute(global::SharpSDL.GLattr attr, ref int value)
        {
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                var __ret = __Internal.GL_GetAttribute(attr, __arg1);
                return __ret;
            }
        }

        /// <summary>
/// <para>Create an OpenGL context for use with an OpenGL window, and make it</para>
/// <para>current.</para>
/// </summary>
/// <remarks>SDL_GL_DeleteContext()</remarks>
        public static global::System.IntPtr GL_CreateContext(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GL_CreateContext(__arg0);
            return __ret;
        }

        /// <summary>Set up an OpenGL context for rendering into an OpenGL window.</summary>
/// <remarks>The context must have been created with a compatible window.</remarks>
        public static int GL_MakeCurrent(global::SharpSDL.Window window, global::System.IntPtr context)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GL_MakeCurrent(__arg0, context);
            return __ret;
        }

        /// <summary>Get the currently active OpenGL window.</summary>
        public static global::SharpSDL.Window GL_GetCurrentWindow()
        {
            var __ret = __Internal.GL_GetCurrentWindow();
            global::SharpSDL.Window __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Window.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Window) global::SharpSDL.Window.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Window.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the currently active OpenGL context.</summary>
        public static global::System.IntPtr GL_GetCurrentContext()
        {
            var __ret = __Internal.GL_GetCurrentContext();
            return __ret;
        }

        /// <summary>
/// <para>Get the size of a window's underlying drawable in pixels (for use</para>
/// <para>with glViewport).</para>
/// </summary>
/// <param name="window">Window from which the drawable size should be queried</param>
/// <param name="w">Pointer to variable for storing the width in pixels, may be NULL</param>
/// <param name="h">Pointer to variable for storing the height in pixels, may be NULL</param>
/// <remarks>
/// <para>This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI</para>
/// <para>drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a</para>
/// <para>platform with high-DPI support (Apple calls this &quot;Retina&quot;), and not disabled</para>
/// <para>by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.</para>
/// <para>SDL_GetWindowSize()</para>
/// <para>SDL_CreateWindow()</para>
/// </remarks>
        public static void GL_GetDrawableSize(global::SharpSDL.Window window, ref int w, ref int h)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    __Internal.GL_GetDrawableSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Set the swap interval for the current OpenGL context.</summary>
/// <param name="interval">
/// <para>0 for immediate updates, 1 for updates synchronized with the</para>
/// <para>vertical retrace. If the system supports it, you may</para>
/// <para>specify -1 to allow late swaps to happen immediately</para>
/// <para>instead of waiting for the next retrace.</para>
/// </param>
/// <returns>0 on success, or -1 if setting the swap interval is not supported.</returns>
/// <remarks>SDL_GL_GetSwapInterval()</remarks>
        public static int GL_SetSwapInterval(int interval)
        {
            var __ret = __Internal.GL_SetSwapInterval(interval);
            return __ret;
        }

        /// <summary>Get the swap interval for the current OpenGL context.</summary>
/// <returns>
/// <para>0 if there is no vertical retrace synchronization, 1 if the buffer</para>
/// <para>swap is synchronized with the vertical retrace, and -1 if late</para>
/// <para>swaps happen immediately instead of waiting for the next retrace.</para>
/// <para>If the system can't determine the swap interval, or there isn't a</para>
/// <para>valid current context, this will return 0 as a safe default.</para>
/// </returns>
/// <remarks>SDL_GL_SetSwapInterval()</remarks>
        public static int GL_GetSwapInterval()
        {
            var __ret = __Internal.GL_GetSwapInterval();
            return __ret;
        }

        /// <summary>
/// <para>Swap the OpenGL buffers for a window, if double-buffering is</para>
/// <para>supported.</para>
/// </summary>
        public static void GL_SwapWindow(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GL_SwapWindow(__arg0);
        }

        /// <summary>Delete an OpenGL context.</summary>
/// <remarks>SDL_GL_CreateContext()</remarks>
        public static void GL_DeleteContext(global::System.IntPtr context)
        {
            __Internal.GL_DeleteContext(context);
        }
    }
}

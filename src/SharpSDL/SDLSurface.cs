// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SharpSDL
{
    /// <summary>The formula used for converting between YUV and RGB</summary>
    public enum YUV_CONVERSION_MODE
    {
        /// <summary>Full range JPEG</summary>
        YUV_CONVERSION_JPEG = 0,
        /// <summary>BT.601 (the default)</summary>
        YUV_CONVERSION_BT601 = 1,
        /// <summary>BT.709</summary>
        YUV_CONVERSION_BT709 = 2,
        /// <summary>BT.601 for SD content, BT.709 for HD content</summary>
        YUV_CONVERSION_AUTOMATIC = 3
    }

    /// <summary>The type of function used for surface blitting functions.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int Blit(global::System.IntPtr src, global::System.IntPtr srcrect, global::System.IntPtr dst, global::System.IntPtr dstrect);

    public unsafe partial class BlitMap
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.BlitMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.BlitMap>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.BlitMap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.BlitMap(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.BlitMap __CreateInstance(global::SharpSDL.BlitMap.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.BlitMap(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.BlitMap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.BlitMap.__Internal));
            *(global::SharpSDL.BlitMap.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BlitMap(global::SharpSDL.BlitMap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BlitMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>A collection of pixels used in software blitting.</summary>
/// <remarks>This structure should be treated as read-only, except forwhich, if not NULL, contains the raw pixel data for the surface.</remarks>
    public unsafe partial class Surface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint flags;

            [FieldOffset(8)]
            internal global::System.IntPtr format;

            [FieldOffset(16)]
            internal int w;

            [FieldOffset(20)]
            internal int h;

            [FieldOffset(24)]
            internal int pitch;

            [FieldOffset(32)]
            internal global::System.IntPtr pixels;

            [FieldOffset(40)]
            internal global::System.IntPtr userdata;

            [FieldOffset(48)]
            internal int locked;

            [FieldOffset(56)]
            internal global::System.IntPtr lock_data;

            [FieldOffset(64)]
            internal global::SharpSDL.Rect.__Internal clip_rect;

            [FieldOffset(80)]
            internal global::System.IntPtr map;

            [FieldOffset(88)]
            internal int refcount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_Surface@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Surface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Surface>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.Surface __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.Surface(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.Surface __CreateInstance(global::SharpSDL.Surface.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.Surface(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.Surface.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.Surface.__Internal));
            *(global::SharpSDL.Surface.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Surface(global::SharpSDL.Surface.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Surface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Surface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.Surface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Surface(global::SharpSDL.Surface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.Surface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.Surface.__Internal*) __Instance) = *((global::SharpSDL.Surface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.Surface __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Flags
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->flags;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->flags = value;
            }
        }

        public global::SharpSDL.PixelFormat Format
        {
            get
            {
                global::SharpSDL.PixelFormat __result0;
                if (((global::SharpSDL.Surface.__Internal*) __Instance)->format == IntPtr.Zero) __result0 = null;
                else if (global::SharpSDL.PixelFormat.NativeToManagedMap.ContainsKey(((global::SharpSDL.Surface.__Internal*) __Instance)->format))
                    __result0 = (global::SharpSDL.PixelFormat) global::SharpSDL.PixelFormat.NativeToManagedMap[((global::SharpSDL.Surface.__Internal*) __Instance)->format];
                else __result0 = global::SharpSDL.PixelFormat.__CreateInstance(((global::SharpSDL.Surface.__Internal*) __Instance)->format);
                return __result0;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->format = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int W
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->w = value;
            }
        }

        public int H
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->h;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->h = value;
            }
        }

        public int Pitch
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->pitch;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->pitch = value;
            }
        }

        public global::System.IntPtr Pixels
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->pixels;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->pixels = (global::System.IntPtr) value;
            }
        }

        public global::System.IntPtr Userdata
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->userdata;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->userdata = (global::System.IntPtr) value;
            }
        }

        public int Locked
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->locked;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->locked = value;
            }
        }

        public global::System.IntPtr LockData
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->lock_data;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->lock_data = (global::System.IntPtr) value;
            }
        }

        public global::SharpSDL.Rect ClipRect
        {
            get
            {
                return global::SharpSDL.Rect.__CreateInstance(new global::System.IntPtr(&((global::SharpSDL.Surface.__Internal*) __Instance)->clip_rect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::SharpSDL.Surface.__Internal*)__Instance)->clip_rect = *(global::SharpSDL.Rect.__Internal*) value.__Instance;
            }
        }

        public global::SharpSDL.BlitMap Map
        {
            get
            {
                global::SharpSDL.BlitMap __result0;
                if (((global::SharpSDL.Surface.__Internal*) __Instance)->map == IntPtr.Zero) __result0 = null;
                else if (global::SharpSDL.BlitMap.NativeToManagedMap.ContainsKey(((global::SharpSDL.Surface.__Internal*) __Instance)->map))
                    __result0 = (global::SharpSDL.BlitMap) global::SharpSDL.BlitMap.NativeToManagedMap[((global::SharpSDL.Surface.__Internal*) __Instance)->map];
                else __result0 = global::SharpSDL.BlitMap.__CreateInstance(((global::SharpSDL.Surface.__Internal*) __Instance)->map);
                return __result0;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->map = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int Refcount
        {
            get
            {
                return ((global::SharpSDL.Surface.__Internal*) __Instance)->refcount;
            }

            set
            {
                ((global::SharpSDL.Surface.__Internal*)__Instance)->refcount = value;
            }
        }
    }

    public unsafe partial class SDLSurface
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateRGBSurface")]
            internal static extern global::System.IntPtr CreateRGBSurface(uint flags, int width, int height, int depth, uint Rmask, uint Gmask, uint Bmask, uint Amask);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateRGBSurfaceWithFormat")]
            internal static extern global::System.IntPtr CreateRGBSurfaceWithFormat(uint flags, int width, int height, int depth, uint format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateRGBSurfaceFrom")]
            internal static extern global::System.IntPtr CreateRGBSurfaceFrom(global::System.IntPtr pixels, int width, int height, int depth, int pitch, uint Rmask, uint Gmask, uint Bmask, uint Amask);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateRGBSurfaceWithFormatFrom")]
            internal static extern global::System.IntPtr CreateRGBSurfaceWithFormatFrom(global::System.IntPtr pixels, int width, int height, int depth, int pitch, uint format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_FreeSurface")]
            internal static extern void FreeSurface(global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetSurfacePalette")]
            internal static extern int SetSurfacePalette(global::System.IntPtr surface, global::System.IntPtr palette);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_LockSurface")]
            internal static extern int LockSurface(global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UnlockSurface")]
            internal static extern void UnlockSurface(global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetSurfaceRLE")]
            internal static extern int SetSurfaceRLE(global::System.IntPtr surface, int flag);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetColorKey")]
            internal static extern int SetColorKey(global::System.IntPtr surface, int flag, uint key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetColorKey")]
            internal static extern int GetColorKey(global::System.IntPtr surface, uint* key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetSurfaceColorMod")]
            internal static extern int SetSurfaceColorMod(global::System.IntPtr surface, byte r, byte g, byte b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetSurfaceColorMod")]
            internal static extern int GetSurfaceColorMod(global::System.IntPtr surface, byte* r, byte* g, byte* b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetSurfaceAlphaMod")]
            internal static extern int SetSurfaceAlphaMod(global::System.IntPtr surface, byte alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetSurfaceAlphaMod")]
            internal static extern int GetSurfaceAlphaMod(global::System.IntPtr surface, byte* alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetSurfaceBlendMode")]
            internal static extern int SetSurfaceBlendMode(global::System.IntPtr surface, global::SharpSDL.BlendMode blendMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetSurfaceBlendMode")]
            internal static extern int GetSurfaceBlendMode(global::System.IntPtr surface, global::SharpSDL.BlendMode* blendMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetClipRect")]
            internal static extern void GetClipRect(global::System.IntPtr surface, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_DuplicateSurface")]
            internal static extern global::System.IntPtr DuplicateSurface(global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ConvertSurface")]
            internal static extern global::System.IntPtr ConvertSurface(global::System.IntPtr src, global::System.IntPtr fmt, uint flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ConvertSurfaceFormat")]
            internal static extern global::System.IntPtr ConvertSurfaceFormat(global::System.IntPtr src, uint pixel_format, uint flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ConvertPixels")]
            internal static extern int ConvertPixels(int width, int height, uint src_format, global::System.IntPtr src, int src_pitch, uint dst_format, global::System.IntPtr dst, int dst_pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_FillRect")]
            internal static extern int FillRect(global::System.IntPtr dst, global::System.IntPtr rect, uint color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_FillRects")]
            internal static extern int FillRects(global::System.IntPtr dst, global::System.IntPtr rects, int count, uint color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UpperBlit")]
            internal static extern int UpperBlit(global::System.IntPtr src, global::System.IntPtr srcrect, global::System.IntPtr dst, global::System.IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_LowerBlit")]
            internal static extern int LowerBlit(global::System.IntPtr src, global::System.IntPtr srcrect, global::System.IntPtr dst, global::System.IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SoftStretch")]
            internal static extern int SoftStretch(global::System.IntPtr src, global::System.IntPtr srcrect, global::System.IntPtr dst, global::System.IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UpperBlitScaled")]
            internal static extern int UpperBlitScaled(global::System.IntPtr src, global::System.IntPtr srcrect, global::System.IntPtr dst, global::System.IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_LowerBlitScaled")]
            internal static extern int LowerBlitScaled(global::System.IntPtr src, global::System.IntPtr srcrect, global::System.IntPtr dst, global::System.IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetYUVConversionMode")]
            internal static extern void SetYUVConversionMode(global::SharpSDL.YUV_CONVERSION_MODE mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetYUVConversionMode")]
            internal static extern global::SharpSDL.YUV_CONVERSION_MODE GetYUVConversionMode();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetYUVConversionModeForResolution")]
            internal static extern global::SharpSDL.YUV_CONVERSION_MODE GetYUVConversionModeForResolution(int width, int height);
        }

        /// <summary>Allocate and free an RGB surface.</summary>
/// <param name="flags">Theare obsolete and should be set to 0.</param>
/// <param name="width">The width in pixels of the surface to create.</param>
/// <param name="height">The height in pixels of the surface to create.</param>
/// <param name="depth">The depth in bits of the surface to create.</param>
/// <param name="Rmask">The red mask of the surface to create.</param>
/// <param name="Gmask">The green mask of the surface to create.</param>
/// <param name="Bmask">The blue mask of the surface to create.</param>
/// <param name="Amask">The alpha mask of the surface to create.</param>
/// <remarks>
/// <para>If the depth is 4 or 8 bits, an empty palette is allocated for the surface.</para>
/// <para>If the depth is greater than 8 bits, the pixel format is set using the</para>
/// <para>flags '[RGB]mask'.</para>
/// <para>If the function runs out of memory, it will return NULL.</para>
/// </remarks>
        public static global::SharpSDL.Surface CreateRGBSurface(uint flags, int width, int height, int depth, uint Rmask, uint Gmask, uint Bmask, uint Amask)
        {
            var __ret = __Internal.CreateRGBSurface(flags, width, height, depth, Rmask, Gmask, Bmask, Amask);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::SharpSDL.Surface CreateRGBSurfaceWithFormat(uint flags, int width, int height, int depth, uint format)
        {
            var __ret = __Internal.CreateRGBSurfaceWithFormat(flags, width, height, depth, format);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::SharpSDL.Surface CreateRGBSurfaceFrom(global::System.IntPtr pixels, int width, int height, int depth, int pitch, uint Rmask, uint Gmask, uint Bmask, uint Amask)
        {
            var __ret = __Internal.CreateRGBSurfaceFrom(pixels, width, height, depth, pitch, Rmask, Gmask, Bmask, Amask);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::SharpSDL.Surface CreateRGBSurfaceWithFormatFrom(global::System.IntPtr pixels, int width, int height, int depth, int pitch, uint format)
        {
            var __ret = __Internal.CreateRGBSurfaceWithFormatFrom(pixels, width, height, depth, pitch, format);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        public static void FreeSurface(global::SharpSDL.Surface surface)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            __Internal.FreeSurface(__arg0);
        }

        /// <summary>Set the palette used by a surface.</summary>
/// <returns>0, or -1 if the surface format doesn't use a palette.</returns>
/// <remarks>A single palette can be shared with many surfaces.</remarks>
        public static int SetSurfacePalette(global::SharpSDL.Surface surface, global::SharpSDL.Palette palette)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __arg1 = ReferenceEquals(palette, null) ? global::System.IntPtr.Zero : palette.__Instance;
            var __ret = __Internal.SetSurfacePalette(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Sets up a surface for directly accessing the pixels.</summary>
/// <remarks>
/// <para>Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write</para>
/// <para>to and read fromusing the pixel format stored in</para>
/// <para>Once you are done accessing the surface, you should</para>
/// <para>use SDL_UnlockSurface() to release it.</para>
/// <para>Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates</para>
/// <para>to 0, then you can read and write to the surface at any time, and the</para>
/// <para>pixel format of the surface will not change.</para>
/// <para>No operating system or library calls should be made between lock/unlock</para>
/// <para>pairs, as critical system locks may be held during this time.</para>
/// <para>SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.</para>
/// <para>SDL_UnlockSurface()</para>
/// </remarks>
        public static int LockSurface(global::SharpSDL.Surface surface)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.LockSurface(__arg0);
            return __ret;
        }

        /// <remarks>SDL_LockSurface()</remarks>
        public static void UnlockSurface(global::SharpSDL.Surface surface)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            __Internal.UnlockSurface(__arg0);
        }

        /// <summary>Sets the RLE acceleration hint for a surface.</summary>
/// <returns>0 on success, or -1 if the surface is not valid</returns>
/// <remarks>
/// <para>If RLE is enabled, colorkey and alpha blending blits are much faster,</para>
/// <para>but the surface must be locked before directly accessing the pixels.</para>
/// </remarks>
        public static int SetSurfaceRLE(global::SharpSDL.Surface surface, int flag)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.SetSurfaceRLE(__arg0, flag);
            return __ret;
        }

        /// <summary>Sets the color key (transparent pixel) in a blittable surface.</summary>
/// <param name="surface">The surface to update</param>
/// <param name="flag">Non-zero to enable colorkey and 0 to disable colorkey</param>
/// <param name="key">The transparent pixel in the native surface format</param>
/// <returns>
/// <para>0 on success, or -1 if the surface is not valid</para>
/// <para>You can pass SDL_RLEACCEL to enable RLE accelerated blits.</para>
/// </returns>
        public static int SetColorKey(global::SharpSDL.Surface surface, int flag, uint key)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.SetColorKey(__arg0, flag, key);
            return __ret;
        }

        /// <summary>Gets the color key (transparent pixel) in a blittable surface.</summary>
/// <param name="surface">The surface to update</param>
/// <param name="key">
/// <para>A pointer filled in with the transparent pixel in the native</para>
/// <para>surface format</para>
/// </param>
/// <returns>
/// <para>0 on success, or -1 if the surface is not valid or colorkey is not</para>
/// <para>enabled.</para>
/// </returns>
        public static int GetColorKey(global::SharpSDL.Surface surface, ref uint key)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            fixed (uint* __key1 = &key)
            {
                var __arg1 = __key1;
                var __ret = __Internal.GetColorKey(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Set an additional color value used in blit operations.</summary>
/// <param name="surface">The surface to update.</param>
/// <param name="r">The red color value multiplied into blit operations.</param>
/// <param name="g">The green color value multiplied into blit operations.</param>
/// <param name="b">The blue color value multiplied into blit operations.</param>
/// <returns>0 on success, or -1 if the surface is not valid.</returns>
/// <remarks>SDL_GetSurfaceColorMod()</remarks>
        public static int SetSurfaceColorMod(global::SharpSDL.Surface surface, byte r, byte g, byte b)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.SetSurfaceColorMod(__arg0, r, g, b);
            return __ret;
        }

        /// <summary>Get the additional color value used in blit operations.</summary>
/// <param name="surface">The surface to query.</param>
/// <param name="r">A pointer filled in with the current red color value.</param>
/// <param name="g">A pointer filled in with the current green color value.</param>
/// <param name="b">A pointer filled in with the current blue color value.</param>
/// <returns>0 on success, or -1 if the surface is not valid.</returns>
/// <remarks>SDL_SetSurfaceColorMod()</remarks>
        public static int GetSurfaceColorMod(global::SharpSDL.Surface surface, byte* r, byte* g, byte* b)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.GetSurfaceColorMod(__arg0, r, g, b);
            return __ret;
        }

        /// <summary>Set an additional alpha value used in blit operations.</summary>
/// <param name="surface">The surface to update.</param>
/// <param name="alpha">The alpha value multiplied into blit operations.</param>
/// <returns>0 on success, or -1 if the surface is not valid.</returns>
/// <remarks>SDL_GetSurfaceAlphaMod()</remarks>
        public static int SetSurfaceAlphaMod(global::SharpSDL.Surface surface, byte alpha)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.SetSurfaceAlphaMod(__arg0, alpha);
            return __ret;
        }

        /// <summary>Get the additional alpha value used in blit operations.</summary>
/// <param name="surface">The surface to query.</param>
/// <param name="alpha">A pointer filled in with the current alpha value.</param>
/// <returns>0 on success, or -1 if the surface is not valid.</returns>
/// <remarks>SDL_SetSurfaceAlphaMod()</remarks>
        public static int GetSurfaceAlphaMod(global::SharpSDL.Surface surface, byte* alpha)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.GetSurfaceAlphaMod(__arg0, alpha);
            return __ret;
        }

        /// <summary>Set the blend mode used for blit operations.</summary>
/// <param name="surface">The surface to update.</param>
/// <param name="blendMode">::SDL_BlendMode to use for blit blending.</param>
/// <returns>0 on success, or -1 if the parameters are not valid.</returns>
/// <remarks>SDL_GetSurfaceBlendMode()</remarks>
        public static int SetSurfaceBlendMode(global::SharpSDL.Surface surface, global::SharpSDL.BlendMode blendMode)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.SetSurfaceBlendMode(__arg0, blendMode);
            return __ret;
        }

        /// <summary>Get the blend mode used for blit operations.</summary>
/// <param name="surface">The surface to query.</param>
/// <param name="blendMode">A pointer filled in with the current blend mode.</param>
/// <returns>0 on success, or -1 if the surface is not valid.</returns>
/// <remarks>SDL_SetSurfaceBlendMode()</remarks>
        public static int GetSurfaceBlendMode(global::SharpSDL.Surface surface, global::SharpSDL.BlendMode* blendMode)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.GetSurfaceBlendMode(__arg0, blendMode);
            return __ret;
        }

        /// <summary>Gets the clipping rectangle for the destination surface in a blit.</summary>
/// <remarks>
/// <para>must be a pointer to a valid rectangle which will be filled</para>
/// <para>with the correct values.</para>
/// </remarks>
        public static void GetClipRect(global::SharpSDL.Surface surface, global::SharpSDL.Rect rect)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            __Internal.GetClipRect(__arg0, __arg1);
        }

        public static global::SharpSDL.Surface DuplicateSurface(global::SharpSDL.Surface surface)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.DuplicateSurface(__arg0);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
/// <para>Creates a new surface of the specified format, and then copies and maps</para>
/// <para>the given surface to it so the blit of the converted surface will be as</para>
/// <para>fast as possible.  If this function fails, it returns NULL.</para>
/// </summary>
/// <remarks>
/// <para>Theparameter is passed to SDL_CreateRGBSurface() and has those</para>
/// <para>semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and</para>
/// <para>SDL will try to RLE accelerate colorkey and alpha blits in the resulting</para>
/// <para>surface.</para>
/// </remarks>
        public static global::SharpSDL.Surface ConvertSurface(global::SharpSDL.Surface src, global::SharpSDL.PixelFormat fmt, uint flags)
        {
            var __arg0 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
            var __arg1 = ReferenceEquals(fmt, null) ? global::System.IntPtr.Zero : fmt.__Instance;
            var __ret = __Internal.ConvertSurface(__arg0, __arg1, flags);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::SharpSDL.Surface ConvertSurfaceFormat(global::SharpSDL.Surface src, uint pixel_format, uint flags)
        {
            var __arg0 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
            var __ret = __Internal.ConvertSurfaceFormat(__arg0, pixel_format, flags);
            global::SharpSDL.Surface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Surface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Surface) global::SharpSDL.Surface.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Surface.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Copy a block of pixels of one format to another format</summary>
/// <returns>0 on success, or -1 if there was an error</returns>
        public static int ConvertPixels(int width, int height, uint src_format, global::System.IntPtr src, int src_pitch, uint dst_format, global::System.IntPtr dst, int dst_pitch)
        {
            var __ret = __Internal.ConvertPixels(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch);
            return __ret;
        }

        /// <summary>Performs a fast fill of the given rectangle with</summary>
/// <returns>0 on success, or -1 on error.</returns>
/// <remarks>
/// <para>Ifis NULL, the whole surface will be filled with</para>
/// <para>The color should be a pixel of the format used by the surface, and</para>
/// <para>can be generated by the SDL_MapRGB() function.</para>
/// </remarks>
        public static int FillRect(global::SharpSDL.Surface dst, global::SharpSDL.Rect rect, uint color)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FillRect(__arg0, __arg1, color);
            return __ret;
        }

        public static int FillRects(global::SharpSDL.Surface dst, global::SharpSDL.Rect rects, int count, uint color)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            var __arg1 = ReferenceEquals(rects, null) ? global::System.IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.FillRects(__arg0, __arg1, count, color);
            return __ret;
        }

        /// <summary>
/// <para>This is the public blit function, SDL_BlitSurface(), and it performs</para>
/// <para>rectangle validation and clipping before passing it to SDL_LowerBlit()</para>
/// </summary>
        public static int UpperBlit(global::SharpSDL.Surface src, global::SharpSDL.Rect srcrect, global::SharpSDL.Surface dst, global::SharpSDL.Rect dstrect)
        {
            var __arg0 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
            var __arg1 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg2 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __ret = __Internal.UpperBlit(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
/// <para>This is a semi-private blit function and it performs low-level surface</para>
/// <para>blitting only.</para>
/// </summary>
        public static int LowerBlit(global::SharpSDL.Surface src, global::SharpSDL.Rect srcrect, global::SharpSDL.Surface dst, global::SharpSDL.Rect dstrect)
        {
            var __arg0 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
            var __arg1 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg2 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __ret = __Internal.LowerBlit(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
/// <para>Perform a fast, low quality, stretch blit between two surfaces of the</para>
/// <para>same pixel format.</para>
/// </summary>
/// <remarks>This function uses a static buffer, and is not thread-safe.</remarks>
        public static int SoftStretch(global::SharpSDL.Surface src, global::SharpSDL.Rect srcrect, global::SharpSDL.Surface dst, global::SharpSDL.Rect dstrect)
        {
            var __arg0 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
            var __arg1 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg2 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __ret = __Internal.SoftStretch(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
/// <para>This is the public scaled blit function, SDL_BlitScaled(), and it performs</para>
/// <para>rectangle validation and clipping before passing it to SDL_LowerBlitScaled()</para>
/// </summary>
        public static int UpperBlitScaled(global::SharpSDL.Surface src, global::SharpSDL.Rect srcrect, global::SharpSDL.Surface dst, global::SharpSDL.Rect dstrect)
        {
            var __arg0 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
            var __arg1 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg2 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __ret = __Internal.UpperBlitScaled(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
/// <para>This is a semi-private blit function and it performs low-level surface</para>
/// <para>scaled blitting only.</para>
/// </summary>
        public static int LowerBlitScaled(global::SharpSDL.Surface src, global::SharpSDL.Rect srcrect, global::SharpSDL.Surface dst, global::SharpSDL.Rect dstrect)
        {
            var __arg0 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
            var __arg1 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg2 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __ret = __Internal.LowerBlitScaled(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>Set the YUV conversion mode</summary>
        public static void SetYUVConversionMode(global::SharpSDL.YUV_CONVERSION_MODE mode)
        {
            __Internal.SetYUVConversionMode(mode);
        }

        /// <summary>Get the YUV conversion mode</summary>
        public static global::SharpSDL.YUV_CONVERSION_MODE GetYUVConversionMode()
        {
            var __ret = __Internal.GetYUVConversionMode();
            return __ret;
        }

        /// <summary>Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC</summary>
        public static global::SharpSDL.YUV_CONVERSION_MODE GetYUVConversionModeForResolution(int width, int height)
        {
            var __ret = __Internal.GetYUVConversionModeForResolution(width, height);
            return __ret;
        }
    }
}

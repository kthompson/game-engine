// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SharpSDL
{
    public enum AssertState
    {
        /// <summary>Retry the assert immediately.</summary>
        ASSERTION_RETRY = 0,
        /// <summary>Make the debugger trigger a breakpoint.</summary>
        ASSERTION_BREAK = 1,
        /// <summary>Terminate the program.</summary>
        ASSERTION_ABORT = 2,
        /// <summary>Ignore the assert.</summary>
        ASSERTION_IGNORE = 3,
        /// <summary>Ignore the assert from now on.</summary>
        ASSERTION_ALWAYS_IGNORE = 4
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::SharpSDL.AssertState AssertionHandler(global::System.IntPtr data, global::System.IntPtr userdata);

    public unsafe partial class AssertData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int always_ignore;

            [FieldOffset(4)]
            internal uint trigger_count;

            [FieldOffset(8)]
            internal global::System.IntPtr condition;

            [FieldOffset(16)]
            internal global::System.IntPtr filename;

            [FieldOffset(24)]
            internal int linenum;

            [FieldOffset(32)]
            internal global::System.IntPtr function;

            [FieldOffset(40)]
            internal global::System.IntPtr next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_AssertData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.AssertData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.AssertData>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.AssertData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.AssertData(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.AssertData __CreateInstance(global::SharpSDL.AssertData.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.AssertData(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.AssertData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AssertData.__Internal));
            *(global::SharpSDL.AssertData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AssertData(global::SharpSDL.AssertData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AssertData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AssertData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AssertData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AssertData(global::SharpSDL.AssertData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.AssertData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.AssertData.__Internal*) __Instance) = *((global::SharpSDL.AssertData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.AssertData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int AlwaysIgnore
        {
            get
            {
                return ((global::SharpSDL.AssertData.__Internal*) __Instance)->always_ignore;
            }

            set
            {
                ((global::SharpSDL.AssertData.__Internal*)__Instance)->always_ignore = value;
            }
        }

        public uint TriggerCount
        {
            get
            {
                return ((global::SharpSDL.AssertData.__Internal*) __Instance)->trigger_count;
            }

            set
            {
                ((global::SharpSDL.AssertData.__Internal*)__Instance)->trigger_count = value;
            }
        }

        public string Condition
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::SharpSDL.AssertData.__Internal*) __Instance)->condition);
            }

            set
            {
                ((global::SharpSDL.AssertData.__Internal*)__Instance)->condition = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string Filename
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::SharpSDL.AssertData.__Internal*) __Instance)->filename);
            }

            set
            {
                ((global::SharpSDL.AssertData.__Internal*)__Instance)->filename = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public int Linenum
        {
            get
            {
                return ((global::SharpSDL.AssertData.__Internal*) __Instance)->linenum;
            }

            set
            {
                ((global::SharpSDL.AssertData.__Internal*)__Instance)->linenum = value;
            }
        }

        public string Function
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::SharpSDL.AssertData.__Internal*) __Instance)->function);
            }

            set
            {
                ((global::SharpSDL.AssertData.__Internal*)__Instance)->function = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public global::SharpSDL.AssertData Next
        {
            get
            {
                global::SharpSDL.AssertData __result0;
                if (((global::SharpSDL.AssertData.__Internal*) __Instance)->next == IntPtr.Zero) __result0 = null;
                else if (global::SharpSDL.AssertData.NativeToManagedMap.ContainsKey(((global::SharpSDL.AssertData.__Internal*) __Instance)->next))
                    __result0 = (global::SharpSDL.AssertData) global::SharpSDL.AssertData.NativeToManagedMap[((global::SharpSDL.AssertData.__Internal*) __Instance)->next];
                else __result0 = global::SharpSDL.AssertData.__CreateInstance(((global::SharpSDL.AssertData.__Internal*) __Instance)->next);
                return __result0;
            }

            set
            {
                ((global::SharpSDL.AssertData.__Internal*)__Instance)->next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class SDLAssert
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ReportAssertion")]
            internal static extern global::SharpSDL.AssertState ReportAssertion(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string _1, [MarshalAs(UnmanagedType.LPStr)] string _2, int _3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetAssertionHandler")]
            internal static extern void SetAssertionHandler(global::System.IntPtr handler, global::System.IntPtr userdata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetDefaultAssertionHandler")]
            internal static extern global::System.IntPtr GetDefaultAssertionHandler();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetAssertionHandler")]
            internal static extern global::System.IntPtr GetAssertionHandler(void** puserdata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetAssertionReport")]
            internal static extern global::System.IntPtr GetAssertionReport();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_ResetAssertionReport")]
            internal static extern void ResetAssertionReport();
        }

        public static global::SharpSDL.AssertState ReportAssertion(global::SharpSDL.AssertData _0, string _1, string _2, int _3)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.ReportAssertion(__arg0, _1, _2, _3);
            return __ret;
        }

        /// <summary>Set an application-defined assertion handler.</summary>
/// <param name="handler">Callback function, called when an assertion fails.</param>
/// <param name="userdata">A pointer passed to the callback as-is.</param>
/// <remarks>
/// <para>This allows an app to show its own assertion UI and/or force the</para>
/// <para>response to an assertion failure. If the app doesn't provide this, SDL</para>
/// <para>will try to do the right thing, popping up a system-specific GUI dialog,</para>
/// <para>and probably minimizing any fullscreen windows.</para>
/// <para>This callback may fire from any thread, but it runs wrapped in a mutex, so</para>
/// <para>it will only fire from one thread at a time.</para>
/// <para>Setting the callback to NULL restores SDL's original internal handler.</para>
/// <para>This callback is NOT reset to SDL's internal handler upon SDL_Quit()!</para>
/// <para>Return SDL_AssertState value of how to handle the assertion failure.</para>
/// </remarks>
        public static void SetAssertionHandler(global::SharpSDL.AssertionHandler handler, global::System.IntPtr userdata)
        {
            var __arg0 = handler == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(handler);
            __Internal.SetAssertionHandler(__arg0, userdata);
        }

        /// <summary>Get the default assertion handler.</summary>
/// <returns>The default SDL_AssertionHandler that is called when an assert triggers.</returns>
/// <remarks>
/// <para>This returns the function pointer that is called by default when an</para>
/// <para>assertion is triggered. This is an internal function provided by SDL,</para>
/// <para>that is used for assertions when SDL_SetAssertionHandler() hasn't been</para>
/// <para>used to provide a different function.</para>
/// </remarks>
        public static global::SharpSDL.AssertionHandler GetDefaultAssertionHandler()
        {
            var __ret = __Internal.GetDefaultAssertionHandler();
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::SharpSDL.AssertionHandler) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SharpSDL.AssertionHandler));
        }

        /// <summary>Get the current assertion handler.</summary>
/// <param name="puserdata">
/// <para>Pointer to a void*, which will store the &quot;userdata&quot;</para>
/// <para>pointer that was passed to SDL_SetAssertionHandler().</para>
/// <para>This value will always be NULL for the default handler.</para>
/// <para>If you don't care about this data, it is safe to pass</para>
/// <para>a NULL pointer to this function to ignore it.</para>
/// </param>
/// <returns>The SDL_AssertionHandler that is called when an assert triggers.</returns>
/// <remarks>
/// <para>This returns the function pointer that is called when an assertion is</para>
/// <para>triggered. This is either the value last passed to</para>
/// <para>SDL_SetAssertionHandler(), or if no application-specified function is</para>
/// <para>set, is equivalent to calling SDL_GetDefaultAssertionHandler().</para>
/// </remarks>
        public static global::SharpSDL.AssertionHandler GetAssertionHandler(void** puserdata)
        {
            var __ret = __Internal.GetAssertionHandler(puserdata);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::SharpSDL.AssertionHandler) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SharpSDL.AssertionHandler));
        }

        /// <summary>Get a list of all assertion failures.</summary>
/// <returns>List of all assertions.</returns>
/// <remarks>
/// <para>Get all assertions triggered since last call to SDL_ResetAssertionReport(),</para>
/// <para>or the start of the program.</para>
/// <para>The proper way to examine this data looks something like this:</para>
/// <para></para>
/// <para>const SDL_AssertData *item = SDL_GetAssertionReport();</para>
/// <para>while (item) {</para>
/// <para>printf(&quot;'%s', %s (%s:%d), triggered %u times, always ignore: %s.\n&quot;,</para>
/// <para>item-&gt;condition, item-&gt;function, item-&gt;filename,</para>
/// <para>item-&gt;linenum, item-&gt;trigger_count,</para>
/// <para>item-&gt;always_ignore ? &quot;yes&quot; : &quot;no&quot;);</para>
/// <para>item = item-&gt;next;</para>
/// <para>}</para>
/// <para>SDL_ResetAssertionReport</para>
/// </remarks>
        public static global::SharpSDL.AssertData GetAssertionReport()
        {
            var __ret = __Internal.GetAssertionReport();
            global::SharpSDL.AssertData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.AssertData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.AssertData) global::SharpSDL.AssertData.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.AssertData.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Reset the list of all assertion failures.</summary>
/// <remarks>
/// <para>Reset list of all assertions triggered.</para>
/// <para>SDL_GetAssertionReport</para>
/// </remarks>
        public static void ResetAssertionReport()
        {
            __Internal.ResetAssertionReport();
        }
    }
}

// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SharpSDL
{
    /// <summary>Flags used when creating a rendering context</summary>
    [Flags]
    public enum RendererFlags
    {
        /// <summary>The renderer is a software fallback</summary>
        RENDERER_SOFTWARE = 1,
        /// <summary>
/// <para>The renderer uses hardware</para>
/// <para>acceleration</para>
/// </summary>
        RENDERER_ACCELERATED = 2,
        /// <summary>
/// <para>Present is synchronized</para>
/// <para>with the refresh rate</para>
/// </summary>
        RENDERER_PRESENTVSYNC = 4,
        /// <summary>
/// <para>The renderer supports</para>
/// <para>rendering to texture</para>
/// </summary>
        RENDERER_TARGETTEXTURE = 8
    }

    /// <summary>The access pattern allowed for a texture.</summary>
    public enum TextureAccess
    {
        /// <summary>Changes rarely, not lockable</summary>
        TEXTUREACCESS_STATIC = 0,
        /// <summary>Changes frequently, lockable</summary>
        TEXTUREACCESS_STREAMING = 1,
        /// <summary>Texture can be used as a render target</summary>
        TEXTUREACCESS_TARGET = 2
    }

    /// <summary>The texture channel modulation used in SDL_RenderCopy().</summary>
    public enum TextureModulate
    {
        /// <summary>No modulation</summary>
        TEXTUREMODULATE_NONE = 0,
        /// <summary>srcC = srcC * color</summary>
        TEXTUREMODULATE_COLOR = 1,
        /// <summary>srcA = srcA * alpha</summary>
        TEXTUREMODULATE_ALPHA = 2
    }

    /// <summary>Flip constants for SDL_RenderCopyEx</summary>
    public enum RendererFlip
    {
        /// <summary>Do not flip</summary>
        FLIP_NONE = 0,
        /// <summary>flip horizontally</summary>
        FLIP_HORIZONTAL = 1,
        /// <summary>flip vertically</summary>
        FLIP_VERTICAL = 2
    }

    /// <summary>A structure representing rendering state</summary>
    public unsafe partial class Renderer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Renderer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Renderer>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.Renderer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.Renderer(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.Renderer __CreateInstance(global::SharpSDL.Renderer.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.Renderer(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.Renderer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.Renderer.__Internal));
            *(global::SharpSDL.Renderer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Renderer(global::SharpSDL.Renderer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Renderer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>An efficient driver-specific representation of pixel data</summary>
    public unsafe partial class Texture
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Texture> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.Texture>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.Texture __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.Texture(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.Texture __CreateInstance(global::SharpSDL.Texture.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.Texture(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.Texture.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.Texture.__Internal));
            *(global::SharpSDL.Texture.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Texture(global::SharpSDL.Texture.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Texture(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Information on the capabilities of a render driver or context.</summary>
    public unsafe partial class RendererInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr name;

            [FieldOffset(8)]
            internal uint flags;

            [FieldOffset(12)]
            internal uint num_texture_formats;

            [FieldOffset(16)]
            internal fixed uint texture_formats[16];

            [FieldOffset(80)]
            internal int max_texture_width;

            [FieldOffset(84)]
            internal int max_texture_height;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SDL_RendererInfo@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.RendererInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SharpSDL.RendererInfo>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::SharpSDL.RendererInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::SharpSDL.RendererInfo(native.ToPointer(), skipVTables);
        }

        internal static global::SharpSDL.RendererInfo __CreateInstance(global::SharpSDL.RendererInfo.__Internal native, bool skipVTables = false)
        {
            return new global::SharpSDL.RendererInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::SharpSDL.RendererInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::SharpSDL.RendererInfo.__Internal));
            *(global::SharpSDL.RendererInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererInfo(global::SharpSDL.RendererInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RendererInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.RendererInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RendererInfo(global::SharpSDL.RendererInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SharpSDL.RendererInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::SharpSDL.RendererInfo.__Internal*) __Instance) = *((global::SharpSDL.RendererInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::SharpSDL.RendererInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::SharpSDL.RendererInfo.__Internal*) __Instance)->name);
            }

            set
            {
                ((global::SharpSDL.RendererInfo.__Internal*)__Instance)->name = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public uint Flags
        {
            get
            {
                return ((global::SharpSDL.RendererInfo.__Internal*) __Instance)->flags;
            }

            set
            {
                ((global::SharpSDL.RendererInfo.__Internal*)__Instance)->flags = value;
            }
        }

        public uint NumTextureFormats
        {
            get
            {
                return ((global::SharpSDL.RendererInfo.__Internal*) __Instance)->num_texture_formats;
            }

            set
            {
                ((global::SharpSDL.RendererInfo.__Internal*)__Instance)->num_texture_formats = value;
            }
        }

        public uint[] TextureFormats
        {
            get
            {
                uint[] __value = null;
                if (((global::SharpSDL.RendererInfo.__Internal*) __Instance)->texture_formats != null)
                {
                    __value = new uint[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = ((global::SharpSDL.RendererInfo.__Internal*) __Instance)->texture_formats[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((global::SharpSDL.RendererInfo.__Internal*)__Instance)->texture_formats[i] = value[i];
                }
            }
        }

        public int MaxTextureWidth
        {
            get
            {
                return ((global::SharpSDL.RendererInfo.__Internal*) __Instance)->max_texture_width;
            }

            set
            {
                ((global::SharpSDL.RendererInfo.__Internal*)__Instance)->max_texture_width = value;
            }
        }

        public int MaxTextureHeight
        {
            get
            {
                return ((global::SharpSDL.RendererInfo.__Internal*) __Instance)->max_texture_height;
            }

            set
            {
                ((global::SharpSDL.RendererInfo.__Internal*)__Instance)->max_texture_height = value;
            }
        }
    }

    public unsafe partial class SDLRender
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetNumRenderDrivers")]
            internal static extern int GetNumRenderDrivers();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetRenderDriverInfo")]
            internal static extern int GetRenderDriverInfo(int index, global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateWindowAndRenderer")]
            internal static extern int CreateWindowAndRenderer(int width, int height, uint window_flags, global::System.IntPtr window, global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateRenderer")]
            internal static extern global::System.IntPtr CreateRenderer(global::System.IntPtr window, int index, uint flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateSoftwareRenderer")]
            internal static extern global::System.IntPtr CreateSoftwareRenderer(global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetRenderer")]
            internal static extern global::System.IntPtr GetRenderer(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetRendererInfo")]
            internal static extern int GetRendererInfo(global::System.IntPtr renderer, global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetRendererOutputSize")]
            internal static extern int GetRendererOutputSize(global::System.IntPtr renderer, int* w, int* h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateTexture")]
            internal static extern global::System.IntPtr CreateTexture(global::System.IntPtr renderer, uint format, int access, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_CreateTextureFromSurface")]
            internal static extern global::System.IntPtr CreateTextureFromSurface(global::System.IntPtr renderer, global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_QueryTexture")]
            internal static extern int QueryTexture(global::System.IntPtr texture, uint* format, int* access, int* w, int* h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetTextureColorMod")]
            internal static extern int SetTextureColorMod(global::System.IntPtr texture, byte r, byte g, byte b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetTextureColorMod")]
            internal static extern int GetTextureColorMod(global::System.IntPtr texture, byte* r, byte* g, byte* b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetTextureAlphaMod")]
            internal static extern int SetTextureAlphaMod(global::System.IntPtr texture, byte alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetTextureAlphaMod")]
            internal static extern int GetTextureAlphaMod(global::System.IntPtr texture, byte* alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetTextureBlendMode")]
            internal static extern int SetTextureBlendMode(global::System.IntPtr texture, global::SharpSDL.BlendMode blendMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetTextureBlendMode")]
            internal static extern int GetTextureBlendMode(global::System.IntPtr texture, global::SharpSDL.BlendMode* blendMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UpdateTexture")]
            internal static extern int UpdateTexture(global::System.IntPtr texture, global::System.IntPtr rect, global::System.IntPtr pixels, int pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UpdateYUVTexture")]
            internal static extern int UpdateYUVTexture(global::System.IntPtr texture, global::System.IntPtr rect, byte* Yplane, int Ypitch, byte* Uplane, int Upitch, byte* Vplane, int Vpitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_LockTexture")]
            internal static extern int LockTexture(global::System.IntPtr texture, global::System.IntPtr rect, void** pixels, int* pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_UnlockTexture")]
            internal static extern void UnlockTexture(global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetRenderTarget")]
            internal static extern int SetRenderTarget(global::System.IntPtr renderer, global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetRenderTarget")]
            internal static extern global::System.IntPtr GetRenderTarget(global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderSetLogicalSize")]
            internal static extern int RenderSetLogicalSize(global::System.IntPtr renderer, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderGetLogicalSize")]
            internal static extern void RenderGetLogicalSize(global::System.IntPtr renderer, int* w, int* h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderSetViewport")]
            internal static extern int RenderSetViewport(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderGetViewport")]
            internal static extern void RenderGetViewport(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderSetClipRect")]
            internal static extern int RenderSetClipRect(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderGetClipRect")]
            internal static extern void RenderGetClipRect(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderSetScale")]
            internal static extern int RenderSetScale(global::System.IntPtr renderer, float scaleX, float scaleY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderGetScale")]
            internal static extern void RenderGetScale(global::System.IntPtr renderer, float* scaleX, float* scaleY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetRenderDrawColor")]
            internal static extern int SetRenderDrawColor(global::System.IntPtr renderer, byte r, byte g, byte b, byte a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetRenderDrawColor")]
            internal static extern int GetRenderDrawColor(global::System.IntPtr renderer, byte* r, byte* g, byte* b, byte* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_SetRenderDrawBlendMode")]
            internal static extern int SetRenderDrawBlendMode(global::System.IntPtr renderer, global::SharpSDL.BlendMode blendMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GetRenderDrawBlendMode")]
            internal static extern int GetRenderDrawBlendMode(global::System.IntPtr renderer, global::SharpSDL.BlendMode* blendMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderClear")]
            internal static extern int RenderClear(global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawPoint")]
            internal static extern int RenderDrawPoint(global::System.IntPtr renderer, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawPoints")]
            internal static extern int RenderDrawPoints(global::System.IntPtr renderer, global::System.IntPtr points, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawLine")]
            internal static extern int RenderDrawLine(global::System.IntPtr renderer, int x1, int y1, int x2, int y2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawLines")]
            internal static extern int RenderDrawLines(global::System.IntPtr renderer, global::System.IntPtr points, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawRect")]
            internal static extern int RenderDrawRect(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawRects")]
            internal static extern int RenderDrawRects(global::System.IntPtr renderer, global::System.IntPtr rects, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderFillRect")]
            internal static extern int RenderFillRect(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderFillRects")]
            internal static extern int RenderFillRects(global::System.IntPtr renderer, global::System.IntPtr rects, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderCopy")]
            internal static extern int RenderCopy(global::System.IntPtr renderer, global::System.IntPtr texture, global::System.IntPtr srcrect, global::System.IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderCopyEx")]
            internal static extern int RenderCopyEx(global::System.IntPtr renderer, global::System.IntPtr texture, global::System.IntPtr srcrect, global::System.IntPtr dstrect, double angle, global::System.IntPtr center, global::SharpSDL.RendererFlip flip);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawPointF")]
            internal static extern int RenderDrawPointF(global::System.IntPtr renderer, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawPointsF")]
            internal static extern int RenderDrawPointsF(global::System.IntPtr renderer, global::System.IntPtr points, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawLineF")]
            internal static extern int RenderDrawLineF(global::System.IntPtr renderer, float x1, float y1, float x2, float y2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawLinesF")]
            internal static extern int RenderDrawLinesF(global::System.IntPtr renderer, global::System.IntPtr points, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawRectF")]
            internal static extern int RenderDrawRectF(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderDrawRectsF")]
            internal static extern int RenderDrawRectsF(global::System.IntPtr renderer, global::System.IntPtr rects, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderFillRectF")]
            internal static extern int RenderFillRectF(global::System.IntPtr renderer, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderFillRectsF")]
            internal static extern int RenderFillRectsF(global::System.IntPtr renderer, global::System.IntPtr rects, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderCopyF")]
            internal static extern int RenderCopyF(global::System.IntPtr renderer, global::System.IntPtr texture, global::System.IntPtr srcrect, global::System.IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderCopyExF")]
            internal static extern int RenderCopyExF(global::System.IntPtr renderer, global::System.IntPtr texture, global::System.IntPtr srcrect, global::System.IntPtr dstrect, double angle, global::System.IntPtr center, global::SharpSDL.RendererFlip flip);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderReadPixels")]
            internal static extern int RenderReadPixels(global::System.IntPtr renderer, global::System.IntPtr rect, uint format, global::System.IntPtr pixels, int pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderPresent")]
            internal static extern void RenderPresent(global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_DestroyTexture")]
            internal static extern void DestroyTexture(global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_DestroyRenderer")]
            internal static extern void DestroyRenderer(global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderFlush")]
            internal static extern int RenderFlush(global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_BindTexture")]
            internal static extern int GL_BindTexture(global::System.IntPtr texture, float* texw, float* texh);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_GL_UnbindTexture")]
            internal static extern int GL_UnbindTexture(global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderGetMetalLayer")]
            internal static extern global::System.IntPtr RenderGetMetalLayer(global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("SDL2", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SDL_RenderGetMetalCommandEncoder")]
            internal static extern global::System.IntPtr RenderGetMetalCommandEncoder(global::System.IntPtr renderer);
        }

        /// <summary>
/// <para>Get the number of 2D rendering drivers available for the current</para>
/// <para>display.</para>
/// </summary>
/// <remarks>
/// <para>A render driver is a set of code that handles rendering and texture</para>
/// <para>management on a particular display.  Normally there is only one, but</para>
/// <para>some drivers may have several available with different capabilities.</para>
/// <para>SDL_GetRenderDriverInfo()</para>
/// <para>SDL_CreateRenderer()</para>
/// </remarks>
        public static int GetNumRenderDrivers()
        {
            var __ret = __Internal.GetNumRenderDrivers();
            return __ret;
        }

        /// <summary>
/// <para>Get information about a specific 2D rendering driver for the current</para>
/// <para>display.</para>
/// </summary>
/// <param name="index">The index of the driver to query information about.</param>
/// <param name="info">
/// <para>A pointer to an SDL_RendererInfo struct to be filled with</para>
/// <para>information on the rendering driver.</para>
/// </param>
/// <returns>0 on success, -1 if the index was out of range.</returns>
/// <remarks>SDL_CreateRenderer()</remarks>
        public static int GetRenderDriverInfo(int index, global::SharpSDL.RendererInfo info)
        {
            var __arg1 = ReferenceEquals(info, null) ? global::System.IntPtr.Zero : info.__Instance;
            var __ret = __Internal.GetRenderDriverInfo(index, __arg1);
            return __ret;
        }

        /// <summary>Create a window and default renderer</summary>
/// <param name="width">The width of the window</param>
/// <param name="height">The height of the window</param>
/// <param name="window_flags">The flags used to create the window</param>
/// <param name="window">A pointer filled with the window, or NULL on error</param>
/// <param name="renderer">A pointer filled with the renderer, or NULL on error</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int CreateWindowAndRenderer(int width, int height, uint window_flags, global::SharpSDL.Window window, global::SharpSDL.Renderer renderer)
        {
            var ____arg3 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg3 = new global::System.IntPtr(&____arg3);
            var ____arg4 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg4 = new global::System.IntPtr(&____arg4);
            var __ret = __Internal.CreateWindowAndRenderer(width, height, window_flags, __arg3, __arg4);
            return __ret;
        }

        /// <summary>Create a 2D rendering context for a window.</summary>
/// <param name="window">The window where rendering is displayed.</param>
/// <param name="index">
/// <para>The index of the rendering driver to initialize, or -1 to</para>
/// <para>initialize the first one supporting the requested flags.</para>
/// </param>
/// <param name="flags">::SDL_RendererFlags.</param>
/// <returns>A valid rendering context or NULL if there was an error.</returns>
/// <remarks>
/// <para>SDL_CreateSoftwareRenderer()</para>
/// <para>SDL_GetRendererInfo()</para>
/// <para>SDL_DestroyRenderer()</para>
/// </remarks>
        public static global::SharpSDL.Renderer CreateRenderer(global::SharpSDL.Window window, int index, uint flags)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.CreateRenderer(__arg0, index, flags);
            global::SharpSDL.Renderer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Renderer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Renderer) global::SharpSDL.Renderer.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Renderer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a 2D software rendering context for a surface.</summary>
/// <param name="surface">The surface where rendering is done.</param>
/// <returns>A valid rendering context or NULL if there was an error.</returns>
/// <remarks>
/// <para>SDL_CreateRenderer()</para>
/// <para>SDL_DestroyRenderer()</para>
/// </remarks>
        public static global::SharpSDL.Renderer CreateSoftwareRenderer(global::SharpSDL.Surface surface)
        {
            var __arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.CreateSoftwareRenderer(__arg0);
            global::SharpSDL.Renderer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Renderer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Renderer) global::SharpSDL.Renderer.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Renderer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the renderer associated with a window.</summary>
        public static global::SharpSDL.Renderer GetRenderer(global::SharpSDL.Window window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetRenderer(__arg0);
            global::SharpSDL.Renderer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Renderer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Renderer) global::SharpSDL.Renderer.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Renderer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get information about a rendering context.</summary>
        public static int GetRendererInfo(global::SharpSDL.Renderer renderer, global::SharpSDL.RendererInfo info)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(info, null) ? global::System.IntPtr.Zero : info.__Instance;
            var __ret = __Internal.GetRendererInfo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get the output size in pixels of a rendering context.</summary>
        public static int GetRendererOutputSize(global::SharpSDL.Renderer renderer, ref int w, ref int h)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    var __ret = __Internal.GetRendererOutputSize(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>Create a texture for a rendering context.</summary>
/// <param name="renderer">The renderer.</param>
/// <param name="format">The format of the texture.</param>
/// <param name="access">One of the enumerated values in ::SDL_TextureAccess.</param>
/// <param name="w">The width of the texture in pixels.</param>
/// <param name="h">The height of the texture in pixels.</param>
/// <returns>
/// <para>The created texture is returned, or NULL if no rendering context was</para>
/// <para>active,  the format was unsupported, or the width or height were out</para>
/// <para>of range.</para>
/// </returns>
/// <remarks>
/// <para>The contents of the texture are not defined at creation.</para>
/// <para>SDL_QueryTexture()</para>
/// <para>SDL_UpdateTexture()</para>
/// <para>SDL_DestroyTexture()</para>
/// </remarks>
        public static global::SharpSDL.Texture CreateTexture(global::SharpSDL.Renderer renderer, uint format, int access, int w, int h)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.CreateTexture(__arg0, format, access, w, h);
            global::SharpSDL.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Texture) global::SharpSDL.Texture.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Texture.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a texture from an existing surface.</summary>
/// <param name="renderer">The renderer.</param>
/// <param name="surface">The surface containing pixel data used to fill the texture.</param>
/// <returns>The created texture is returned, or NULL on error.</returns>
/// <remarks>
/// <para>The surface is not modified or freed by this function.</para>
/// <para>SDL_QueryTexture()</para>
/// <para>SDL_DestroyTexture()</para>
/// </remarks>
        public static global::SharpSDL.Texture CreateTextureFromSurface(global::SharpSDL.Renderer renderer, global::SharpSDL.Surface surface)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = __Internal.CreateTextureFromSurface(__arg0, __arg1);
            global::SharpSDL.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Texture) global::SharpSDL.Texture.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Texture.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Query the attributes of a texture</summary>
/// <param name="texture">A texture to be queried.</param>
/// <param name="format">
/// <para>A pointer filled in with the raw format of the texture.  The</para>
/// <para>actual format may differ, but pixel transfers will use this</para>
/// <para>format.</para>
/// </param>
/// <param name="access">A pointer filled in with the actual access to the texture.</param>
/// <param name="w">A pointer filled in with the width of the texture in pixels.</param>
/// <param name="h">A pointer filled in with the height of the texture in pixels.</param>
/// <returns>0 on success, or -1 if the texture is not valid.</returns>
        public static int QueryTexture(global::SharpSDL.Texture texture, ref uint format, ref int access, ref int w, ref int h)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            fixed (uint* __format1 = &format)
            {
                var __arg1 = __format1;
                fixed (int* __access2 = &access)
                {
                    var __arg2 = __access2;
                    fixed (int* __w3 = &w)
                    {
                        var __arg3 = __w3;
                        fixed (int* __h4 = &h)
                        {
                            var __arg4 = __h4;
                            var __ret = __Internal.QueryTexture(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>Set an additional color value used in render copy operations.</summary>
/// <param name="texture">The texture to update.</param>
/// <param name="r">The red color value multiplied into copy operations.</param>
/// <param name="g">The green color value multiplied into copy operations.</param>
/// <param name="b">The blue color value multiplied into copy operations.</param>
/// <returns>
/// <para>0 on success, or -1 if the texture is not valid or color modulation</para>
/// <para>is not supported.</para>
/// </returns>
/// <remarks>SDL_GetTextureColorMod()</remarks>
        public static int SetTextureColorMod(global::SharpSDL.Texture texture, byte r, byte g, byte b)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.SetTextureColorMod(__arg0, r, g, b);
            return __ret;
        }

        /// <summary>Get the additional color value used in render copy operations.</summary>
/// <param name="texture">The texture to query.</param>
/// <param name="r">A pointer filled in with the current red color value.</param>
/// <param name="g">A pointer filled in with the current green color value.</param>
/// <param name="b">A pointer filled in with the current blue color value.</param>
/// <returns>0 on success, or -1 if the texture is not valid.</returns>
/// <remarks>SDL_SetTextureColorMod()</remarks>
        public static int GetTextureColorMod(global::SharpSDL.Texture texture, byte* r, byte* g, byte* b)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.GetTextureColorMod(__arg0, r, g, b);
            return __ret;
        }

        /// <summary>Set an additional alpha value used in render copy operations.</summary>
/// <param name="texture">The texture to update.</param>
/// <param name="alpha">The alpha value multiplied into copy operations.</param>
/// <returns>
/// <para>0 on success, or -1 if the texture is not valid or alpha modulation</para>
/// <para>is not supported.</para>
/// </returns>
/// <remarks>SDL_GetTextureAlphaMod()</remarks>
        public static int SetTextureAlphaMod(global::SharpSDL.Texture texture, byte alpha)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.SetTextureAlphaMod(__arg0, alpha);
            return __ret;
        }

        /// <summary>Get the additional alpha value used in render copy operations.</summary>
/// <param name="texture">The texture to query.</param>
/// <param name="alpha">A pointer filled in with the current alpha value.</param>
/// <returns>0 on success, or -1 if the texture is not valid.</returns>
/// <remarks>SDL_SetTextureAlphaMod()</remarks>
        public static int GetTextureAlphaMod(global::SharpSDL.Texture texture, byte* alpha)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.GetTextureAlphaMod(__arg0, alpha);
            return __ret;
        }

        /// <summary>Set the blend mode used for texture copy operations.</summary>
/// <param name="texture">The texture to update.</param>
/// <param name="blendMode">::SDL_BlendMode to use for texture blending.</param>
/// <returns>
/// <para>0 on success, or -1 if the texture is not valid or the blend mode is</para>
/// <para>not supported.</para>
/// </returns>
/// <remarks>
/// <para>If the blend mode is not supported, the closest supported mode is</para>
/// <para>chosen.</para>
/// <para>SDL_GetTextureBlendMode()</para>
/// </remarks>
        public static int SetTextureBlendMode(global::SharpSDL.Texture texture, global::SharpSDL.BlendMode blendMode)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.SetTextureBlendMode(__arg0, blendMode);
            return __ret;
        }

        /// <summary>Get the blend mode used for texture copy operations.</summary>
/// <param name="texture">The texture to query.</param>
/// <param name="blendMode">A pointer filled in with the current blend mode.</param>
/// <returns>0 on success, or -1 if the texture is not valid.</returns>
/// <remarks>SDL_SetTextureBlendMode()</remarks>
        public static int GetTextureBlendMode(global::SharpSDL.Texture texture, global::SharpSDL.BlendMode* blendMode)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.GetTextureBlendMode(__arg0, blendMode);
            return __ret;
        }

        /// <summary>Update the given texture rectangle with new pixel data.</summary>
/// <param name="texture">The texture to update</param>
/// <param name="rect">
/// <para>A pointer to the rectangle of pixels to update, or NULL to</para>
/// <para>update the entire texture.</para>
/// </param>
/// <param name="pixels">The raw pixel data in the format of the texture.</param>
/// <param name="pitch">The number of bytes in a row of pixel data, including padding between lines.</param>
/// <returns>0 on success, or -1 if the texture is not valid.</returns>
/// <remarks>
/// <para>The pixel data must be in the format of the texture. The pixel format can be</para>
/// <para>queried with SDL_QueryTexture.</para>
/// <para>This is a fairly slow function.</para>
/// </remarks>
        public static int UpdateTexture(global::SharpSDL.Texture texture, global::SharpSDL.Rect rect, global::System.IntPtr pixels, int pitch)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.UpdateTexture(__arg0, __arg1, pixels, pitch);
            return __ret;
        }

        /// <summary>Update a rectangle within a planar YV12 or IYUV texture with new pixel data.</summary>
/// <param name="texture">The texture to update</param>
/// <param name="rect">
/// <para>A pointer to the rectangle of pixels to update, or NULL to</para>
/// <para>update the entire texture.</para>
/// </param>
/// <param name="Yplane">The raw pixel data for the Y plane.</param>
/// <param name="Ypitch">The number of bytes between rows of pixel data for the Y plane.</param>
/// <param name="Uplane">The raw pixel data for the U plane.</param>
/// <param name="Upitch">The number of bytes between rows of pixel data for the U plane.</param>
/// <param name="Vplane">The raw pixel data for the V plane.</param>
/// <param name="Vpitch">The number of bytes between rows of pixel data for the V plane.</param>
/// <returns>0 on success, or -1 if the texture is not valid.</returns>
/// <remarks>
/// <para>You can use SDL_UpdateTexture() as long as your pixel data is</para>
/// <para>a contiguous block of Y and U/V planes in the proper order, but</para>
/// <para>this function is available if your pixel data is not contiguous.</para>
/// </remarks>
        public static int UpdateYUVTexture(global::SharpSDL.Texture texture, global::SharpSDL.Rect rect, byte* Yplane, int Ypitch, byte* Uplane, int Upitch, byte* Vplane, int Vpitch)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.UpdateYUVTexture(__arg0, __arg1, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch);
            return __ret;
        }

        /// <summary>Lock a portion of the texture for write-only pixel access.</summary>
/// <param name="texture">
/// <para>The texture to lock for access, which was created with</para>
/// <para>::SDL_TEXTUREACCESS_STREAMING.</para>
/// </param>
/// <param name="rect">
/// <para>A pointer to the rectangle to lock for access. If the rect</para>
/// <para>is NULL, the entire texture will be locked.</para>
/// </param>
/// <param name="pixels">
/// <para>This is filled in with a pointer to the locked pixels,</para>
/// <para>appropriately offset by the locked area.</para>
/// </param>
/// <param name="pitch">This is filled in with the pitch of the locked pixels.</param>
/// <returns>0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.</returns>
/// <remarks>SDL_UnlockTexture()</remarks>
        public static int LockTexture(global::SharpSDL.Texture texture, global::SharpSDL.Rect rect, void** pixels, ref int pitch)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            fixed (int* __pitch3 = &pitch)
            {
                var __arg3 = __pitch3;
                var __ret = __Internal.LockTexture(__arg0, __arg1, pixels, __arg3);
                return __ret;
            }
        }

        /// <summary>Unlock a texture, uploading the changes to video memory, if needed.</summary>
/// <remarks>SDL_LockTexture()</remarks>
        public static void UnlockTexture(global::SharpSDL.Texture texture)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            __Internal.UnlockTexture(__arg0);
        }

        /// <summary>Set a texture as the current rendering target.</summary>
/// <param name="renderer">The renderer.</param>
/// <param name="texture">The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target</param>
/// <returns>0 on success, or -1 on error</returns>
/// <remarks>SDL_GetRenderTarget()</remarks>
        public static int SetRenderTarget(global::SharpSDL.Renderer renderer, global::SharpSDL.Texture texture)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.SetRenderTarget(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get the current render target or NULL for the default render target.</summary>
/// <returns>The current render target</returns>
/// <remarks>SDL_SetRenderTarget()</remarks>
        public static global::SharpSDL.Texture GetRenderTarget(global::SharpSDL.Renderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.GetRenderTarget(__arg0);
            global::SharpSDL.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::SharpSDL.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::SharpSDL.Texture) global::SharpSDL.Texture.NativeToManagedMap[__ret];
            else __result0 = global::SharpSDL.Texture.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set device independent resolution for rendering</summary>
/// <param name="renderer">The renderer for which resolution should be set.</param>
/// <param name="w">The width of the logical resolution</param>
/// <param name="h">The height of the logical resolution</param>
/// <remarks>
/// <para>This function uses the viewport and scaling functionality to allow a fixed logical</para>
/// <para>resolution for rendering, regardless of the actual output resolution.  If the actual</para>
/// <para>output resolution doesn't have the same aspect ratio the output rendering will be</para>
/// <para>centered within the output display.</para>
/// <para>If the output display is a window, mouse events in the window will be filtered</para>
/// <para>and scaled so they seem to arrive within the logical resolution.</para>
/// <para>If this function results in scaling or subpixel drawing by the</para>
/// <para>rendering backend, it will be handled using the appropriate</para>
/// <para>quality hints.</para>
/// <para>SDL_RenderGetLogicalSize()</para>
/// <para>SDL_RenderSetScale()</para>
/// <para>SDL_RenderSetViewport()</para>
/// </remarks>
        public static int RenderSetLogicalSize(global::SharpSDL.Renderer renderer, int w, int h)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderSetLogicalSize(__arg0, w, h);
            return __ret;
        }

        /// <summary>Get device independent resolution for rendering</summary>
/// <param name="renderer">The renderer from which resolution should be queried.</param>
/// <param name="w">A pointer filled with the width of the logical resolution</param>
/// <param name="h">A pointer filled with the height of the logical resolution</param>
/// <remarks>SDL_RenderSetLogicalSize()</remarks>
        public static void RenderGetLogicalSize(global::SharpSDL.Renderer renderer, ref int w, ref int h)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    __Internal.RenderGetLogicalSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Set the drawing area for rendering on the current target.</summary>
/// <param name="renderer">The renderer for which the drawing area should be set.</param>
/// <param name="rect">The rectangle representing the drawing area, or NULL to set the viewport to the entire target.</param>
/// <returns>0 on success, or -1 on error</returns>
/// <remarks>
/// <para>The x,y of the viewport rect represents the origin for rendering.</para>
/// <para>If the window associated with the renderer is resized, the viewport is automatically reset.</para>
/// <para>SDL_RenderGetViewport()</para>
/// <para>SDL_RenderSetLogicalSize()</para>
/// </remarks>
        public static int RenderSetViewport(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.RenderSetViewport(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get the drawing area for the current target.</summary>
/// <remarks>SDL_RenderSetViewport()</remarks>
        public static void RenderGetViewport(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            __Internal.RenderGetViewport(__arg0, __arg1);
        }

        /// <summary>Set the clip rectangle for the current target.</summary>
/// <param name="renderer">The renderer for which clip rectangle should be set.</param>
/// <param name="rect">
/// <para>A pointer to the rectangle to set as the clip rectangle, or</para>
/// <para>NULL to disable clipping.</para>
/// </param>
/// <returns>0 on success, or -1 on error</returns>
/// <remarks>SDL_RenderGetClipRect()</remarks>
        public static int RenderSetClipRect(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.RenderSetClipRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get the clip rectangle for the current target.</summary>
/// <param name="renderer">The renderer from which clip rectangle should be queried.</param>
/// <param name="rect">
/// <para>A pointer filled in with the current clip rectangle, or</para>
/// <para>an empty rectangle if clipping is disabled.</para>
/// </param>
/// <remarks>SDL_RenderSetClipRect()</remarks>
        public static void RenderGetClipRect(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            __Internal.RenderGetClipRect(__arg0, __arg1);
        }

        /// <summary>Set the drawing scale for rendering on the current target.</summary>
/// <param name="renderer">The renderer for which the drawing scale should be set.</param>
/// <param name="scaleX">The horizontal scaling factor</param>
/// <param name="scaleY">The vertical scaling factor</param>
/// <remarks>
/// <para>The drawing coordinates are scaled by the x/y scaling factors</para>
/// <para>before they are used by the renderer.  This allows resolution</para>
/// <para>independent drawing with a single coordinate system.</para>
/// <para>If this results in scaling or subpixel drawing by the</para>
/// <para>rendering backend, it will be handled using the appropriate</para>
/// <para>quality hints.  For best results use integer scaling factors.</para>
/// <para>SDL_RenderGetScale()</para>
/// <para>SDL_RenderSetLogicalSize()</para>
/// </remarks>
        public static int RenderSetScale(global::SharpSDL.Renderer renderer, float scaleX, float scaleY)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderSetScale(__arg0, scaleX, scaleY);
            return __ret;
        }

        /// <summary>Get the drawing scale for the current target.</summary>
/// <param name="renderer">The renderer from which drawing scale should be queried.</param>
/// <param name="scaleX">A pointer filled in with the horizontal scaling factor</param>
/// <param name="scaleY">A pointer filled in with the vertical scaling factor</param>
/// <remarks>SDL_RenderSetScale()</remarks>
        public static void RenderGetScale(global::SharpSDL.Renderer renderer, ref float scaleX, ref float scaleY)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            fixed (float* __scaleX1 = &scaleX)
            {
                var __arg1 = __scaleX1;
                fixed (float* __scaleY2 = &scaleY)
                {
                    var __arg2 = __scaleY2;
                    __Internal.RenderGetScale(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Set the color used for drawing operations (Rect, Line and Clear).</summary>
/// <param name="renderer">The renderer for which drawing color should be set.</param>
/// <param name="r">The red value used to draw on the rendering target.</param>
/// <param name="g">The green value used to draw on the rendering target.</param>
/// <param name="b">The blue value used to draw on the rendering target.</param>
/// <param name="a">
/// <para>The alpha value used to draw on the rendering target, usually</para>
/// <para>::SDL_ALPHA_OPAQUE (255).</para>
/// </param>
/// <returns>0 on success, or -1 on error</returns>
        public static int SetRenderDrawColor(global::SharpSDL.Renderer renderer, byte r, byte g, byte b, byte a)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.SetRenderDrawColor(__arg0, r, g, b, a);
            return __ret;
        }

        /// <summary>Get the color used for drawing operations (Rect, Line and Clear).</summary>
/// <param name="renderer">The renderer from which drawing color should be queried.</param>
/// <param name="r">A pointer to the red value used to draw on the rendering target.</param>
/// <param name="g">A pointer to the green value used to draw on the rendering target.</param>
/// <param name="b">A pointer to the blue value used to draw on the rendering target.</param>
/// <param name="a">
/// <para>A pointer to the alpha value used to draw on the rendering target,</para>
/// <para>usually ::SDL_ALPHA_OPAQUE (255).</para>
/// </param>
/// <returns>0 on success, or -1 on error</returns>
        public static int GetRenderDrawColor(global::SharpSDL.Renderer renderer, byte* r, byte* g, byte* b, byte* a)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.GetRenderDrawColor(__arg0, r, g, b, a);
            return __ret;
        }

        /// <summary>Set the blend mode used for drawing operations (Fill and Line).</summary>
/// <param name="renderer">The renderer for which blend mode should be set.</param>
/// <param name="blendMode">::SDL_BlendMode to use for blending.</param>
/// <returns>0 on success, or -1 on error</returns>
/// <remarks>
/// <para>If the blend mode is not supported, the closest supported mode is</para>
/// <para>chosen.</para>
/// <para>SDL_GetRenderDrawBlendMode()</para>
/// </remarks>
        public static int SetRenderDrawBlendMode(global::SharpSDL.Renderer renderer, global::SharpSDL.BlendMode blendMode)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.SetRenderDrawBlendMode(__arg0, blendMode);
            return __ret;
        }

        /// <summary>Get the blend mode used for drawing operations.</summary>
/// <param name="renderer">The renderer from which blend mode should be queried.</param>
/// <param name="blendMode">A pointer filled in with the current blend mode.</param>
/// <returns>0 on success, or -1 on error</returns>
/// <remarks>SDL_SetRenderDrawBlendMode()</remarks>
        public static int GetRenderDrawBlendMode(global::SharpSDL.Renderer renderer, global::SharpSDL.BlendMode* blendMode)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.GetRenderDrawBlendMode(__arg0, blendMode);
            return __ret;
        }

        /// <summary>Clear the current rendering target with the drawing color</summary>
/// <returns>0 on success, or -1 on error</returns>
/// <remarks>
/// <para>This function clears the entire rendering target, ignoring the viewport and</para>
/// <para>the clip rectangle.</para>
/// </remarks>
        public static int RenderClear(global::SharpSDL.Renderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderClear(__arg0);
            return __ret;
        }

        /// <summary>Draw a point on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw a point.</param>
/// <param name="x">The x coordinate of the point.</param>
/// <param name="y">The y coordinate of the point.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawPoint(global::SharpSDL.Renderer renderer, int x, int y)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderDrawPoint(__arg0, x, y);
            return __ret;
        }

        /// <summary>Draw multiple points on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw multiple points.</param>
/// <param name="points">The points to draw</param>
/// <param name="count">The number of points to draw</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawPoints(global::SharpSDL.Renderer renderer, global::SharpSDL.Point points, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            var __ret = __Internal.RenderDrawPoints(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Draw a line on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw a line.</param>
/// <param name="x1">The x coordinate of the start point.</param>
/// <param name="y1">The y coordinate of the start point.</param>
/// <param name="x2">The x coordinate of the end point.</param>
/// <param name="y2">The y coordinate of the end point.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawLine(global::SharpSDL.Renderer renderer, int x1, int y1, int x2, int y2)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderDrawLine(__arg0, x1, y1, x2, y2);
            return __ret;
        }

        /// <summary>Draw a series of connected lines on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw multiple lines.</param>
/// <param name="points">The points along the lines</param>
/// <param name="count">The number of points, drawing count-1 lines</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawLines(global::SharpSDL.Renderer renderer, global::SharpSDL.Point points, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            var __ret = __Internal.RenderDrawLines(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Draw a rectangle on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw a rectangle.</param>
/// <param name="rect">A pointer to the destination rectangle, or NULL to outline the entire rendering target.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawRect(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.RenderDrawRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Draw some number of rectangles on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw multiple rectangles.</param>
/// <param name="rects">A pointer to an array of destination rectangles.</param>
/// <param name="count">The number of rectangles.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawRects(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rects, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rects, null) ? global::System.IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.RenderDrawRects(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Fill a rectangle on the current rendering target with the drawing color.</summary>
/// <param name="renderer">The renderer which should fill a rectangle.</param>
/// <param name="rect">
/// <para>A pointer to the destination rectangle, or NULL for the entire</para>
/// <para>rendering target.</para>
/// </param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderFillRect(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.RenderFillRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Fill some number of rectangles on the current rendering target with the drawing color.</summary>
/// <param name="renderer">The renderer which should fill multiple rectangles.</param>
/// <param name="rects">A pointer to an array of destination rectangles.</param>
/// <param name="count">The number of rectangles.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderFillRects(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rects, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rects, null) ? global::System.IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.RenderFillRects(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Copy a portion of the texture to the current rendering target.</summary>
/// <param name="renderer">The renderer which should copy parts of a texture.</param>
/// <param name="texture">The source texture.</param>
/// <param name="srcrect">
/// <para>A pointer to the source rectangle, or NULL for the entire</para>
/// <para>texture.</para>
/// </param>
/// <param name="dstrect">
/// <para>A pointer to the destination rectangle, or NULL for the</para>
/// <para>entire rendering target.</para>
/// </param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderCopy(global::SharpSDL.Renderer renderer, global::SharpSDL.Texture texture, global::SharpSDL.Rect srcrect, global::SharpSDL.Rect dstrect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __arg2 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __ret = __Internal.RenderCopy(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center</summary>
/// <param name="renderer">The renderer which should copy parts of a texture.</param>
/// <param name="texture">The source texture.</param>
/// <param name="srcrect">
/// <para>A pointer to the source rectangle, or NULL for the entire</para>
/// <para>texture.</para>
/// </param>
/// <param name="dstrect">
/// <para>A pointer to the destination rectangle, or NULL for the</para>
/// <para>entire rendering target.</para>
/// </param>
/// <param name="angle">An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction</param>
/// <param name="center">A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).</param>
/// <param name="flip">An SDL_RendererFlip value stating which flipping actions should be performed on the texture</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderCopyEx(global::SharpSDL.Renderer renderer, global::SharpSDL.Texture texture, global::SharpSDL.Rect srcrect, global::SharpSDL.Rect dstrect, double angle, global::SharpSDL.Point center, global::SharpSDL.RendererFlip flip)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __arg2 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __arg5 = ReferenceEquals(center, null) ? global::System.IntPtr.Zero : center.__Instance;
            var __ret = __Internal.RenderCopyEx(__arg0, __arg1, __arg2, __arg3, angle, __arg5, flip);
            return __ret;
        }

        /// <summary>Draw a point on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw a point.</param>
/// <param name="x">The x coordinate of the point.</param>
/// <param name="y">The y coordinate of the point.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawPointF(global::SharpSDL.Renderer renderer, float x, float y)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderDrawPointF(__arg0, x, y);
            return __ret;
        }

        /// <summary>Draw multiple points on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw multiple points.</param>
/// <param name="points">The points to draw</param>
/// <param name="count">The number of points to draw</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawPointsF(global::SharpSDL.Renderer renderer, global::SharpSDL.FPoint points, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            var __ret = __Internal.RenderDrawPointsF(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Draw a line on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw a line.</param>
/// <param name="x1">The x coordinate of the start point.</param>
/// <param name="y1">The y coordinate of the start point.</param>
/// <param name="x2">The x coordinate of the end point.</param>
/// <param name="y2">The y coordinate of the end point.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawLineF(global::SharpSDL.Renderer renderer, float x1, float y1, float x2, float y2)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderDrawLineF(__arg0, x1, y1, x2, y2);
            return __ret;
        }

        /// <summary>Draw a series of connected lines on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw multiple lines.</param>
/// <param name="points">The points along the lines</param>
/// <param name="count">The number of points, drawing count-1 lines</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawLinesF(global::SharpSDL.Renderer renderer, global::SharpSDL.FPoint points, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            var __ret = __Internal.RenderDrawLinesF(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Draw a rectangle on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw a rectangle.</param>
/// <param name="rect">A pointer to the destination rectangle, or NULL to outline the entire rendering target.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawRectF(global::SharpSDL.Renderer renderer, global::SharpSDL.FRect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.RenderDrawRectF(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Draw some number of rectangles on the current rendering target.</summary>
/// <param name="renderer">The renderer which should draw multiple rectangles.</param>
/// <param name="rects">A pointer to an array of destination rectangles.</param>
/// <param name="count">The number of rectangles.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderDrawRectsF(global::SharpSDL.Renderer renderer, global::SharpSDL.FRect rects, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rects, null) ? global::System.IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.RenderDrawRectsF(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Fill a rectangle on the current rendering target with the drawing color.</summary>
/// <param name="renderer">The renderer which should fill a rectangle.</param>
/// <param name="rect">
/// <para>A pointer to the destination rectangle, or NULL for the entire</para>
/// <para>rendering target.</para>
/// </param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderFillRectF(global::SharpSDL.Renderer renderer, global::SharpSDL.FRect rect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.RenderFillRectF(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Fill some number of rectangles on the current rendering target with the drawing color.</summary>
/// <param name="renderer">The renderer which should fill multiple rectangles.</param>
/// <param name="rects">A pointer to an array of destination rectangles.</param>
/// <param name="count">The number of rectangles.</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderFillRectsF(global::SharpSDL.Renderer renderer, global::SharpSDL.FRect rects, int count)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rects, null) ? global::System.IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.RenderFillRectsF(__arg0, __arg1, count);
            return __ret;
        }

        /// <summary>Copy a portion of the texture to the current rendering target.</summary>
/// <param name="renderer">The renderer which should copy parts of a texture.</param>
/// <param name="texture">The source texture.</param>
/// <param name="srcrect">
/// <para>A pointer to the source rectangle, or NULL for the entire</para>
/// <para>texture.</para>
/// </param>
/// <param name="dstrect">
/// <para>A pointer to the destination rectangle, or NULL for the</para>
/// <para>entire rendering target.</para>
/// </param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderCopyF(global::SharpSDL.Renderer renderer, global::SharpSDL.Texture texture, global::SharpSDL.Rect srcrect, global::SharpSDL.FRect dstrect)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __arg2 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __ret = __Internal.RenderCopyF(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center</summary>
/// <param name="renderer">The renderer which should copy parts of a texture.</param>
/// <param name="texture">The source texture.</param>
/// <param name="srcrect">
/// <para>A pointer to the source rectangle, or NULL for the entire</para>
/// <para>texture.</para>
/// </param>
/// <param name="dstrect">
/// <para>A pointer to the destination rectangle, or NULL for the</para>
/// <para>entire rendering target.</para>
/// </param>
/// <param name="angle">An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction</param>
/// <param name="center">A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).</param>
/// <param name="flip">An SDL_RendererFlip value stating which flipping actions should be performed on the texture</param>
/// <returns>0 on success, or -1 on error</returns>
        public static int RenderCopyExF(global::SharpSDL.Renderer renderer, global::SharpSDL.Texture texture, global::SharpSDL.Rect srcrect, global::SharpSDL.FRect dstrect, double angle, global::SharpSDL.FPoint center, global::SharpSDL.RendererFlip flip)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __arg2 = ReferenceEquals(srcrect, null) ? global::System.IntPtr.Zero : srcrect.__Instance;
            var __arg3 = ReferenceEquals(dstrect, null) ? global::System.IntPtr.Zero : dstrect.__Instance;
            var __arg5 = ReferenceEquals(center, null) ? global::System.IntPtr.Zero : center.__Instance;
            var __ret = __Internal.RenderCopyExF(__arg0, __arg1, __arg2, __arg3, angle, __arg5, flip);
            return __ret;
        }

        /// <summary>Read pixels from the current rendering target.</summary>
/// <param name="renderer">The renderer from which pixels should be read.</param>
/// <param name="rect">
/// <para>A pointer to the rectangle to read, or NULL for the entire</para>
/// <para>render target.</para>
/// </param>
/// <param name="format">
/// <para>The desired format of the pixel data, or 0 to use the format</para>
/// <para>of the rendering target</para>
/// </param>
/// <param name="pixels">A pointer to be filled in with the pixel data</param>
/// <param name="pitch">The pitch of the pixels parameter.</param>
/// <returns>0 on success, or -1 if pixel reading is not supported.</returns>
/// <remarks>This is a very slow operation, and should not be used frequently.</remarks>
        public static int RenderReadPixels(global::SharpSDL.Renderer renderer, global::SharpSDL.Rect rect, uint format, global::System.IntPtr pixels, int pitch)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.RenderReadPixels(__arg0, __arg1, format, pixels, pitch);
            return __ret;
        }

        /// <summary>Update the screen with rendering performed.</summary>
        public static void RenderPresent(global::SharpSDL.Renderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            __Internal.RenderPresent(__arg0);
        }

        /// <summary>Destroy the specified texture.</summary>
/// <remarks>
/// <para>SDL_CreateTexture()</para>
/// <para>SDL_CreateTextureFromSurface()</para>
/// </remarks>
        public static void DestroyTexture(global::SharpSDL.Texture texture)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            __Internal.DestroyTexture(__arg0);
        }

        /// <summary>
/// <para>Destroy the rendering context for a window and free associated</para>
/// <para>textures.</para>
/// </summary>
/// <remarks>SDL_CreateRenderer()</remarks>
        public static void DestroyRenderer(global::SharpSDL.Renderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            __Internal.DestroyRenderer(__arg0);
        }

        /// <summary>
/// <para>Force the rendering context to flush any pending commands to the</para>
/// <para>underlying rendering API.</para>
/// </summary>
/// <remarks>
/// <para>You do not need to (and in fact, shouldn't) call this function unless</para>
/// <para>you are planning to call into OpenGL/Direct3D/Metal/whatever directly</para>
/// <para>in addition to using an SDL_Renderer.</para>
/// <para>This is for a very-specific case: if you are using SDL's render API,</para>
/// <para>you asked for a specific renderer backend (OpenGL, Direct3D, etc),</para>
/// <para>you set SDL_HINT_RENDER_BATCHING to &quot;1&quot;, and you plan to make</para>
/// <para>OpenGL/D3D/whatever calls in addition to SDL render API calls. If all of</para>
/// <para>this applies, you should call SDL_RenderFlush() between calls to SDL's</para>
/// <para>render API and the low-level API you're using in cooperation.</para>
/// <para>In all other cases, you can ignore this function. This is only here to</para>
/// <para>get maximum performance out of a specific situation. In all other cases,</para>
/// <para>SDL will do the right thing, perhaps at a performance loss.</para>
/// <para>This function is first available in SDL 2.0.10, and is not needed in</para>
/// <para>2.0.9 and earlier, as earlier versions did not queue rendering commands</para>
/// <para>at all, instead flushing them to the OS immediately.</para>
/// </remarks>
        public static int RenderFlush(global::SharpSDL.Renderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderFlush(__arg0);
            return __ret;
        }

        /// <summary>
/// <para>Bind the texture to the current OpenGL/ES/ES2 context for use with</para>
/// <para>OpenGL instructions.</para>
/// </summary>
/// <param name="texture">The SDL texture to bind</param>
/// <param name="texw">A pointer to a float that will be filled with the texture width</param>
/// <param name="texh">A pointer to a float that will be filled with the texture height</param>
/// <returns>0 on success, or -1 if the operation is not supported</returns>
        public static int GL_BindTexture(global::SharpSDL.Texture texture, ref float texw, ref float texh)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            fixed (float* __texw1 = &texw)
            {
                var __arg1 = __texw1;
                fixed (float* __texh2 = &texh)
                {
                    var __arg2 = __texh2;
                    var __ret = __Internal.GL_BindTexture(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>Unbind a texture from the current OpenGL/ES/ES2 context.</summary>
/// <param name="texture">The SDL texture to unbind</param>
/// <returns>0 on success, or -1 if the operation is not supported</returns>
        public static int GL_UnbindTexture(global::SharpSDL.Texture texture)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            var __ret = __Internal.GL_UnbindTexture(__arg0);
            return __ret;
        }

        /// <summary>Get the CAMetalLayer associated with the given Metal renderer</summary>
/// <param name="renderer">The renderer to query</param>
/// <returns>CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer</returns>
/// <remarks>SDL_RenderGetMetalCommandEncoder()</remarks>
        public static global::System.IntPtr RenderGetMetalLayer(global::SharpSDL.Renderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderGetMetalLayer(__arg0);
            return __ret;
        }

        /// <summary>Get the Metal command encoder for the current frame</summary>
/// <param name="renderer">The renderer to query</param>
/// <returns>id&gt; on success, or NULL if the renderer isn't a Metal renderer</returns>
/// <remarks>SDL_RenderGetMetalLayer()</remarks>
        public static global::System.IntPtr RenderGetMetalCommandEncoder(global::SharpSDL.Renderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RenderGetMetalCommandEncoder(__arg0);
            return __ret;
        }
    }
}
